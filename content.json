{"posts":[{"title":"MVP Pattern","text":"MVC模式(Model-View-Controller)：MVC模式在開發UI中是一種非常受歡迎的設計模式。 MVC主要想法為：將程式劃分為模型（Model）、視圖（View）和控制器（Controller） Model：主要負責管理資料邏輯。Model拿到資料後將資料交給View。 在此可以直接與資料庫、API 或其他資料來源交互。 在此不執行遊戲邏輯或是執行運算。 View：負責顯示資料。 它從Model中獲取資料，並將這些資料呈現給使用者。View僅關注如何顯示資料。 Controller：充當Model和View之間的溝通的橋樑。 它接收使用者的輸入，呼叫Model來處理這些輸入，然後選擇適當的View來顯示處理結果。 可以把它想像為大腦，它處理遊戲資料並在執行期間計算資料是如何改變的。 MVC模式符合單一職責原則，每個部分都只負責自己的部分。 在Unity中，UI Toolkit或是Unity UI很自然地負責擔任View 缺點 MVC模式中三者相互依賴，一但更新了其中一個，另外兩個也須跟著修改。 Controller的程式碼會隨著功能的添加越來越臃腫。 import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.esm.min.mjs'; mermaid.initialize({ startOnLoad: true }); graph TD A[ User ] -->| Interacts with | B[ View ] B -->| Sends user input to | C[ Controller ] C -->| Updates | D[ Model ] D -->| Notifies changes to | B[ View ] B -->| Displays data from | D[ Model ] MVP模式(Model-View-Presenter)：MVP是MVC的一種變體 MVP將Controller改爲Presenter，並改變了通信方向。當Model拿到資料之後，不直接給View更新，而是交給Presenter，之後Presenter再把資料交給View，View再更新畫面。 View：只負責收到使用者回饋，之後呼叫Presenter拿取資料，並在接收到資料時，更新畫面。 Model：被動的接收到Presenter命令，拿取資料，並回傳給Presenter。 Presenter：Model和View之間的的橋樑，與View和Model溝通。 從三者相互依賴變成都只依賴Presenter M &lt;=&gt; P &lt;=&gt; V 之間雙向通信但View與Model不通信 Presenter的程式碼會隨著功能的添加越來越臃腫。 graph TD A[ User ] -->| Interacts with | B[ View ] B -->| Sends user input to | C[ Presenter ] C -->| Updates | D[ Model ] D -->| Notifies changes to | C[ Presenter ] C -->| Updates | B[ View ] B -->| Displays data from | C[ Presenter ] 使用MVP模式製作生命條UI：Health類 在此Health類的身份是Model，保存真正的生命資料 含有一個HealthChanged event，每當有更改生命值的動作時，都會呼叫這個event。 Health類只負責增加，減少生命值，符合符合單一職責原則123456789101112131415161718192021222324252627282930313233343536373839404142public class Health : MonoBehaviour{ public event Action HealthChanged; private const int minHealth = 0; private const int maxHealth = 100; private int currentHealth; public int CurrentHealth { get =&gt; currentHealth; set =&gt; currentHealth = value; } public int MinHealth =&gt; minHealth; public int MaxHealth =&gt; maxHealth; public void Increment(int amount) { currentHealth += amount; currentHealth = Mathf.Clamp(currentHealth, minHealth, maxHealth); UpdateHealth(); } public void Decrement(int amount) { currentHealth -= amount; currentHealth = Mathf.Clamp(currentHealth, minHealth, maxHealth); UpdateHealth(); } public void Restore() { currentHealth = maxHealth; UpdateHealth(); } private void UpdateHealth() { HealthChanged?.Invoke(); }} HealthPresenter類 HealthPresenter類含有Health類的依賴，用來操控Health 其他物件不會直接操控Health類，而是透過HealthPresenter類暴露的Damage與Heal以及Reset來操控12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class HealthPresenter : MonoBehaviour{ // 在MVP中的Model [SerializeField] private Health health; // 在MVP中的View [SerializeField] private Slider healthSlider; private void Start() { if (health != null) { health.HealthChanged += OnHealthChanged; } UpdateView(); } private void OnDestroy() { if (health != null) { health.HealthChanged -= OnHealthChanged; } } public void Damage(int amount) { health?.Decrement(amount); } public void Heal(int amount) { health?.Increment(amount); } public void Reset() { health?.Restore(); } public void UpdateView() { if (health == null) return; if (healthSlider != null &amp;&amp; health.MaxHealth != 0) { healthSlider.value = (float)health.CurrentHealth / health.MaxHealth; } } private void OnHealthChanged() { UpdateView(); }} ClickDamage類：為使用HealthPresenter的類 不直接操控 Model (Health)與 View (healthSlider)而是透過HealthPresenter1234567891011121314151617181920212223242526[RequireComponent(typeof(HealthPresenter), typeof(Collider))]public class ClickDamage : MonoBehaviour{ private Collider collider; private HealthPresenter healthPresenter; [SerializeField] private LayerMask layerToClick; [SerializeField] private int damageValue = 10; private void Start() { collider = GetComponent&lt;Collider&gt;(); healthPresenter = GetComponent&lt;HealthPresenter&gt;(); } private void Update() { if (Input.GetMouseButtonDown(0)) { Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition); if (Physics.Raycast(ray, Mathf.Infinity, layerToClick)) { healthPresenter?.Damage(damageValue); } } }} Reference: https://github.com/Unity-Technologies/game-programming-patterns-demo/tree/main/Assets/12%20MVPhttps://github.com/push-pop/Unity-MVVM/blob/main/Docs/Architechture.md","link":"/2024/05/27/2024-05-27-mvp-pattern/"},{"title":"閱讀Level Up Your Code With Game Programming Patterns","text":"這本 Unity 的電子書《Level up your code with game programming patterns》 對於提升遊戲開發者的程式設計能力非常有幫助。以下是該電子書的網址與Github網址：https://blog.unity.com/games/level-up-your-code-with-game-programming-patternsGithub：https://github.com/Unity-Technologies/game-programming-patterns-demo/tree/main 這本書介紹了工程師必須了解的SOLID 原則(SOLID principles)，這些原則是編寫高質量程式碼的基礎，SOLID原則是以下五大原則的簡稱： 單一職責原則(Single responsibility)：確保類只負責一件事。 開閉原則(Open-closed)：在不更改現有程式碼的情況下，可以擴展一個類的功能。 里氏替換原則(Liskov substitution)：子類可以替代基類，而不影響程式的正確性。 介面隔離原則(Interface segregation)：讓介面(interface)盡可能簡單，確保實作類只需要實作其所需的介面方法。 依賴倒置原則(Dependency inversion)：高層模組不應依賴於低層模組，兩者都應依賴於抽象。具體實現應依賴於抽象，而不是抽象依賴於具體實現。 這些原則可以讓你的程式設計更具彈性和可維護性，但在不確定是否要使用它們時，請記住KISS（Keep It Simple, Stupid）原則，不要強迫將其應用於程式碼中。 這本電子書也介紹了以下常用在遊戲開發中的設計模式 工廠模式(Factory pattern)：把生成物件的邏輯封裝起來，讓一個特別的物件(工廠Factory)去建立其他物件(產品Product)。 物件池模式(Object Pool pattern)：預先建立一組物件並存放在池中，重用這些物件以減少資源浪費。 單例模式(Singleton pattern)：確保一個特別的類只有一個並可全局訪問的實體。 命令模式(Command Pattern)：將一系列特定動作封裝為命令物件(Command object)，讓這些命令可以撤銷(undo)或是重做(redo) 狀態模式(State Pattern)：讓物件的行為隨內部狀態改變而改變。 觀察者模式(Observer pattern)：當一個物件的狀態改變時，會自動通知所有想要接收此訊息的物件。 MVP模式(Model-View-Presenter)：MVP模式是使用者介面設計模式的一種，它是MVC模式的一種衍生模式，在此模式中，Presenter充當了Model和View之間的橋樑。由Presenter在View與Model之間雙向通信，但View與Model不通信 MVVM模式(Model-View-ViewModel)：MVVM模式是使用者介面設計模式的一種，它是MVC模式的一種衍生模式，它透過觀察者模式(Observer pattern)將 View 與 ViewModel 連接在一起， 在 ViewModel 中進行資料綁定(data binding)。當 View Model 的狀態改變時自動通知 View。","link":"/2024/05/27/2024-05-27-%E9%96%B1%E8%AE%80level-up-your-code-with-game-programming-patterns/"},{"title":"State Pattern","text":"狀態模式(State pattern)： 當物件的內部狀態改變時，物件的行為也會隨之改變，即物件會根據當前狀態執行不同的行為。 每個狀態的行為是獨立定義的。添加新狀態不會影響現有狀態的行為。 在遊戲中會需要不斷地追蹤遊戲中的各種狀態，例如玩家走路(Walking)，跳躍(Jumping)，待命(Idle或Standing)等。若你把它畫成流程圖(flowchart)可能會發現 一次只有一個狀態會被啟用(Active) 狀態會依據不同的條件去轉換到另外一個狀態 當轉換發生時，新的狀態會成為啟用狀態(Active state) 這種狀態轉換圖被稱為有限狀態機(Finite state machine，FSM) 以下是一個使用Enum去實作的簡單有限狀態機： 123456public enum PlayerControllerState{ Idle, Walk, Jump} 在這個Controller類中，使用switch轉換狀態，很快你會發現當狀態越來越多後，Controller會變得一團亂，例如增加幾個狀態，就必須要不斷的更改Controller： 123456789101112131415161718192021222324252627282930313233343536public class UnrefactoredPlayerController : MonoBehaviour{ private PlayerControllerState state; private void Update() { GetInput(); switch (state) { case PlayerControllerState.Idle: Idle(); break; case PlayerControllerState.Walk: Walk(); break; case PlayerControllerState.Jump: Jump(); break; } } private void GetInput() { // 處理行走和跳躍控制 } private void Walk() { // 行走邏輯 } private void Idle() { // 待命邏輯 } private void Jump() { // 跳躍邏輯 }} 使用狀態模式，在遊戲中，你可以想像處理角色狀態需要： 當條件滿足時，第一次進入(Enter)這個狀態時需要處理一些事。 在遊戲迴圈中根據這個狀態不斷的更新(Update)角色的值。 當條件不滿足或是滿足某些離開條件時，離開(Exit)這個狀態時，要在離開前處理一些事。因此根據這樣的流程定義一個抽象介面(Interface)，IState並定義它有以下方法： Enter：第一次進入這個狀態時需要做的邏輯 Update： 在每一幀中需要執行的邏輯(有時也稱Exceute或Tick)。它會根據這個狀態在每一幀中不斷的更新角色的值。 Exit：在離開這個狀態前要做的邏輯123456789101112131415public interface IState{ public void Enter() { // 當第一次進入狀態時運行的邏輯 } public void Update() { // 每幀邏輯，包括轉換到新狀態的條件 } public void Exit() { // 當離開狀態時運行的邏輯 }} 行走狀態：在這個狀態中，Update()會不斷地移動這個角色，另外也會判斷是否要切換到其他狀態。 123456789101112131415161718192021222324252627282930313233343536373839public class WalkState : IState{ private Color meshColor = Color.blue; public Color MeshColor { get =&gt; meshColor; set =&gt; meshColor = value; } private PlayerController player; // 可以在建構子中傳遞任何需要的參數 public WalkState(PlayerController player) { this.player = player; } public void Enter() { //Debug.Log(&quot;Entering Walk State&quot;); } public void Update() { // 如果不再在地面上，轉換到跳躍狀態 if (!player.IsGrounded) { player.PlayerStateMachine.TransitionTo(player.PlayerStateMachine.jumpState); } // 如果速度降到最低臨界值以內，轉換到待命狀態 if (Mathf.Abs(player.CharController.velocity.x) &lt; 0.1f &amp;&amp; Mathf.Abs(player.CharController.velocity.z) &lt; 0.1f) { player.PlayerStateMachine.TransitionTo(player.PlayerStateMachine.idleState); } } public void Exit() { //Debug.Log(&quot;Exiting Walk State&quot;); }} 待命狀態 12345678910111213141516171819202122232425262728293031323334353637public class IdleState : IState{ private PlayerController player; private Color meshColor = Color.gray; public Color MeshColor { get =&gt; meshColor; set =&gt; meshColor = value; } public IdleState(PlayerController player) { this.player = player; } public void Enter() { Debug.Log(&quot;Entering Idle State&quot;); } public void Update() { // 如果不再在地面上，轉換到跳躍狀態 if (!player.IsGrounded) { player.PlayerStateMachine.TransitionTo(player.PlayerStateMachine.jumpState); } // 如果速度超過臨界值，轉換到移動狀態 if (Mathf.Abs(player.CharController.velocity.x) &gt; 0.1f || Mathf.Abs(player.CharController.velocity.z) &gt; 0.1f) { player.PlayerStateMachine.TransitionTo(player.PlayerStateMachine.walkState); } } public void Exit() { Debug.Log(&quot;Exiting Idle State&quot;); }} StateMachine負責管理這些狀態 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class StateMachine{ public IState CurrentState { get; private set; } // 目前狀態 // 狀態物件的引用 public WalkState walkState; public JumpState jumpState; public IdleState idleState; // 用於通知其他物件狀態改變的事件 public event Action&lt;IState&gt; stateChanged; // 由於沒有繼承 MonoBehaviour，因此需要通過建構子將 PlayerController 傳入 public StateMachine(PlayerController player) { // 建立每個狀態的實體並傳遞 PlayerController this.walkState = new WalkState(player); this.jumpState = new JumpState(player); this.idleState = new IdleState(player); } // 設置初始狀態 public void Initialize(IState state) { CurrentState = state; state.Enter(); // 通知其他物件狀態已改變 stateChanged?.Invoke(state); } // 退出目前狀態並進入另一個狀態 public void TransitionTo(IState nextState) { CurrentState.Exit(); CurrentState = nextState; nextState.Enter(); // 通知其他物件狀態已改變 stateChanged?.Invoke(nextState); } public void Update() { if (CurrentState != null) { CurrentState.Update(); } }} 在Controller中使用StateMachine 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125[RequireComponent(typeof(PlayerInput), typeof(CharacterController))]public class PlayerController : MonoBehaviour{ [SerializeField] private PlayerInput playerInput; private StateMachine playerStateMachine; [Header(&quot;Movement&quot;)] [Tooltip(&quot;Horizontal speed&quot;)] [SerializeField] private float moveSpeed = 5f; [Tooltip(&quot;Rate of change for move speed&quot;)] [SerializeField] private float acceleration = 10f; [Tooltip(&quot;Max height to jump&quot;)] [SerializeField] private float jumpHeight = 1.25f; [Tooltip(&quot;Custom gravity for player&quot;)] [SerializeField] private float gravity = -15f; [Tooltip(&quot;Time between jumps&quot;)] [SerializeField] private float jumpTimeout = 0.1f; [SerializeField] private bool isGrounded = true; // 是否在地面上 [SerializeField] private float groundedRadius = 0.5f; // 檢查是否在地面的半徑 [SerializeField] private float groundedOffset = 0.15f; [SerializeField] private LayerMask groundLayers; public CharacterController CharController =&gt; charController; public bool IsGrounded =&gt; isGrounded; public StateMachine PlayerStateMachine =&gt; playerStateMachine; private CharacterController charController; private float targetSpeed; private float verticalVelocity; private float jumpCooldown; private void Awake() { playerInput = GetComponent&lt;PlayerInput&gt;(); charController = GetComponent&lt;CharacterController&gt;(); // 初始化狀態機 playerStateMachine = new StateMachine(this); } private void Start() { playerStateMachine.Initialize(playerStateMachine.idleState); // 設置初始狀態為 idleState } private void Update() { // 使用目前狀態更新角色資料 playerStateMachine.Update(); } private void LateUpdate() { CalculateVertical(); Move(); } private void Move() { Vector3 inputVector = playerInput.InputVector; if (inputVector == Vector3.zero) { targetSpeed = 0; } float currentHorizontalSpeed = new Vector3(charController.velocity.x, 0.0f, charController.velocity.z).magnitude; float tolerance = 0.1f; if (currentHorizontalSpeed &lt; targetSpeed - tolerance || currentHorizontalSpeed &gt; targetSpeed + tolerance) { targetSpeed = Mathf.Lerp(currentHorizontalSpeed, targetSpeed, Time.deltaTime * acceleration); targetSpeed = Mathf.Round(targetSpeed * 1000f) / 1000f; } else { targetSpeed = moveSpeed; } charController.Move((inputVector.normalized * targetSpeed * Time.deltaTime) + new Vector3(0f, verticalVelocity, 0f) * Time.deltaTime); } private void CalculateVertical() { if (isGrounded) { if (verticalVelocity &lt; 0f) { verticalVelocity = -2f; } if (playerInput.IsJumping &amp;&amp; jumpCooldown &lt;= 0f) { verticalVelocity = Mathf.Sqrt(jumpHeight * -2f * gravity); } if (jumpCooldown &gt;= 0f) { jumpCooldown -= Time.deltaTime; } } else { jumpCooldown = jumpTimeout; playerInput.IsJumping = false; } verticalVelocity += gravity * Time.deltaTime; Vector3 spherePosition = new Vector3(transform.position.x, transform.position.y + groundedOffset, transform.position.z); isGrounded = Physics.CheckSphere(spherePosition, 0.5f, groundLayers, QueryTriggerInteraction.Ignore); } private void OnDrawGizmosSelected() { Color transparentGreen = new Color(0.0f, 1.0f, 0.0f, 0.35f); Color transparentRed = new Color(1.0f, 0.0f, 0.0f, 0.35f); Gizmos.color = isGrounded ? transparentGreen : transparentRed; Gizmos.DrawSphere(new Vector3(transform.position.x, transform.position.y + groundedOffset, transform.position.z), groundedRadius); }} Reference: https://github.com/Unity-Technologies/game-programming-patterns-demo/tree/main/Assets/10%20State/Scripts","link":"/2024/05/27/2024-05-27-state-pattern/"},{"title":"2D車輪關節(Wheel Joint 2D)","text":"2D車輪關節(Wheel Joint 2D)：是一種物理關節，可以用它來模擬轉動的車輪， 可以為它施加馬達動力(motor power)， 它使用了懸吊彈簧(suspension spring)來保持與車輛主體(main body of the vehicle)的距離。 這種關節可用來模擬車輪(wheels)和懸掛系統(suspension)。其目的是保持兩個點在一條延伸到無限遠的直線上，同時使它們重疊(overlap)。這兩個點可以是兩個Rigidbody2D組件，也可以是一個Rigidbody2D組件和世界中的一個固定位置（通過將Connected Rigidbody設置為None來連接到世界中的固定位置）。 簡單的說：2D車輪關節(Wheel Joint 2D)，讓兩個點保持在同一條直線上，而這條直線是可以延伸到無限遠的。同時，當沒有外力作用時，這兩個點會保持在一起(即重疊)。 Wheel Joint 2D類似於Slider Joint 2D（無馬達動力或限制約束）和Hinge Joint 2D（無限制約束）的組合。這種關節對兩個連接的剛體(rigid body)物件施加線性力(linear force)，使它們保持在線上，並施加角度馬達(angular motor)以使物件在線上旋轉(rotate)，同時用彈簧(spring)來模擬車輪懸掛(wheel suspension)。 Play Unity Test on itch.io 設置Maximum Motor Speed（最大馬達速度）與Maximum Motor Force（最大馬達動力）控制角馬達速度，讓兩個剛體物體旋轉。Maximum Motor Force（最大馬達動力）：設置角馬達的最大扭矩。 即馬達所能施加的最大旋轉力。這個最大扭矩的設置對於控制車輪的轉動速度和力量非常重要。例如： 如果 Maximum Motor Force 設置得太小，馬達可能無法提供足夠的扭矩來驅動車輪，特別是在遇到障礙或需要加速的情況下。 如果 Maximum Motor Force 設置得太大，馬達可能會施加過大的扭矩，導致車輪快速旋轉，可能會影響車輛的穩定性模擬懸掛可以設置車輪懸掛的硬度和運動，以模擬不同程度的懸掛效果。例如，模擬硬且幾乎不動的懸掛： 設置高頻率（Frequency）（1,000,000是最高值）== 硬懸掛。 設置高阻尼比（Damping Ratio）（1是最高值）== 幾乎不動的懸掛。 若要模擬有彈性且自由運動的懸掛，可以使用以下設置： 設置低頻率 == 鬆弛的懸掛。 設置低阻尼比 == 可動的懸掛。 保持零相對線性距離(zero relative linear distance)：在兩個剛體物體的錨點之間指定的線上保持零相對線性距離。保持角速度(angular speed)：在兩個剛體物體的錨點之間保持角速度（通過Maximum Motor Speed選項設置速度，通過Maximum Motor Force設置最大扭矩）。 應用場景 這種關節適用於構建需要像是通過旋轉樞軸連接，但不能脫離指定線的物理對象。例如：模擬具有馬達驅動的車輪。 屬性 功能 Enable Collision 啟用這個屬性後，可以偵測碰撞。 Connected Rigid Body 指定此關節連接到的其他遊戲物件(GameObject)。如果將此設置為「None」，則關節的另一端固定在由「Connected Anchor」設置定義的空間點。 Auto Configure Connected Anchor 啟用此屬性以自動設置此關節連接到的遊戲物件的錨點(Anchor)位置。如果啟用此屬性，則不需要為「Connected Anchor」屬性輸入座標。 Anchor 定義此遊戲物件的2D剛體(Rigidbody2D)上的關節(joint)端點連接的位置（以x、y座標表示）。 Connected Anchor 定義這個關節(joint)端點要連接到另一個遊戲物件的2D剛體(Rigidbody2D)上的位置（以x、y座標表示）。 Suspension 選擇此選項以展開此屬性的設置。 Damping Ratio(阻尼比) 控制彈簧(spring)振盪(oscillation)的關節設置。較高的阻尼比意味著彈簧會更快停止振盪 Frequency 設定遊戲物件接近所需分離距離時彈簧振盪的頻率（以每秒週期數為單位）。範圍為0到1,000,000，值越高，彈簧越硬，也就是說越不容易來回振動。注意：將頻率設置為零會創建最硬的彈簧類型關節(即不振動) Angle 設定懸掛系統(suspension)的世界(World)運動角度 Use Motor 啟用此選項以對關節應用馬達動力。 Motor 選擇此選項以展開此屬性的設置。 Motor Speed 設定馬達要達到的目標速度（每秒度數）。 Maximum Motor Force 設定馬達在嘗試達到目標速度時可以施加的最大扭矩(torque)（或旋轉力(rotation)）。 Break Action 設置當超過力(force)臨界值或達到扭矩臨界值(torque threshold)時採取的動作。 Break Force 設置力的臨界值，當超過時這個關節就會執行選擇的Break Action。預設值為Infinity，表示不執行Break Action。 Break Torque 設置扭矩的臨界值，當超過時這個關節就會執行選擇的Break Action。預設值為Infinity，表示不執行Break Action。 Damping Ratio(阻尼比)：描述系統在受到擾動後振盪及衰減的情形。阻尼比越大，物件受力振盪後越快恢復原狀。 無阻尼：= 0 ， 對應沒有阻尼的簡諧運動。 欠阻尼：&lt; 1 ， 指數遞減且振盪 過阻尼：&gt; 1 ， 沒有振盪的指數遞減 臨界阻尼：= 1 ， 介於過阻尼及欠阻尼之間，是許多工程應用想要的結果 https://zh.wikipedia.org/zh-tw/%E9%98%BB%E5%B0%BC%E6%AF%94 Reference：https://docs.unity3d.com/Manual/class-WheelJoint2D.html","link":"/2024/05/29/2024-05-29-wheel-joint-2d/"},{"title":"MVVM Pattern","text":"MVVM模式(Model–View–ViewModel)：MVVM將程式劃分為 Model ， View 與 ViewModel ，它透過觀察者模式將 View 與 ViewModel 連接在一起， 在 ViewModel 中進行資料綁定(data binding)。當 View Model 的狀態改變時自動通知 View。 Model：主要負責管理資料邏輯。 View：負責顯示資料以及與使用者互動。 ViewModel：是連接 Model 和 View 的橋樑。與 MVC中的 Controller 和 MVP 中的 Presenter 不同在於 ViewModel 它會綁定(Binder) View 要顯示的資料，當資料改變時，自動通知 View 要更新UI。 通常使用資料綁定(Data Binding)機制來實現這一點 import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid@10.9.1/dist/mermaid.esm.min.mjs'; mermaid.initialize({ startOnLoad: true }); graph TD A[ View ] B[ ViewModel ] C[ Model ] A -->| User Interaction | B B -->| Notify Changes | A B | Data Binding | A B -->| Calls | C C -->| Data | B Unity中，UGUI沒有內建Data Binding，需要自己實作一個，以下是一個簡單的範例 定義一個 Model 12345public class Model{ public string Name { get; set; } public string Job { get; set;}} 定義一個Model Service，其職責為從PlayerPrefs拿資料，或是將資料寫入PlayerPrefs 123456789101112131415161718192021222324public class ModelService{ public Model GetData() { Model m = new Model() { Name = PlayerPrefs.GetString(&quot;name&quot;), Job = PlayerPrefs.GetString(&quot;job&quot;), }; return m; } public void SaveNmae(string name) { PlayerPrefs.SetString(&quot;name&quot;, name); } public void SaveJob(string job) { PlayerPrefs.SetString(&quot;job&quot;, job); }} 定義一個BindableProperty類，它含有一個OnValueChanged事件，當Value的值發生變化(通過set方法)時，就會呼叫 OnValueChanged ，從而通知有註冊這個事件的物件。 123456789101112131415161718192021222324252627282930public class BindableProperty&lt;T&gt;{ public delegate void ValueChangedHandler(T oldValue, T newValue); public event ValueChangedHandler OnValueChanged; private T _value; public T Value { get { return _value; } set { if (!object.Equals(_value, value)) { T oldValue = _value; _value = value; // 通知值發生改變 OnValueChanged?.Invoke(oldValue, _value); } } } public override string ToString() { return (Value != null ? Value.ToString() : &quot;null&quot;); }} 接下來定義一個 ViewModel ， 這個 ViewModel 將負責為 View 提供資料，但它不知曉 View 的任何資訊，與 View 解耦，專注於資料的處理 1234567891011121314151617181920212223242526272829303132333435363738394041public class ViewModel{ public BindableProperty&lt;string&gt; Name = new BindableProperty&lt;string&gt;(); public BindableProperty&lt;string&gt; Job = new BindableProperty&lt;string&gt;(); private ModelService service = new ModelService(); public ViewModel() {} public void GetModel() { Model m = service.GetData(); Name.Value = m.Name; Job.Value = m.Job; Debug.Log(m.Name + &quot; &quot; + m.Job); } public void SaveModel() { // do some check string name = Name.Value; string job = Job.Value; if (name == null || name.Length &gt; 0) { return; } if (job == null || job.Length &gt; 0) { return; } service.SaveNmae(Name.Value); service.SaveJob(Job.Value); }} 最後定義一個 View ，這個 View 包含了要操控的UI元件，因此繼承了MonoBehaviour，它不處理資料邏輯，只負責顯示格式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class View : MonoBehaviour{ public TMP_InputField nameInputField; public TextMeshProUGUI nameMessageText; public TMP_InputField jobInputField; public TextMeshProUGUI jobMessageText; public TextMeshProUGUI resultText; public Button applyButton; public ViewModel viewModel; private void Start() { viewModel = new ViewModel(); viewModel.Name.OnValueChanged += OnNameChanged; nameInputField.onValueChanged.AddListener(OnNameInputChanged); viewModel.Job.OnValueChanged += OnJobChanged; jobInputField.onValueChanged.AddListener(OnJobInputChanged); applyButton.onClick.AddListener(OnApplyButtonClick); viewModel.GetModel(); } private void OnDestroy() { viewModel.Name.OnValueChanged -= OnNameChanged; nameInputField.onValueChanged.RemoveListener(OnNameInputChanged); viewModel.Job.OnValueChanged -= OnJobChanged; jobInputField.onValueChanged.RemoveListener(OnJobInputChanged); applyButton.onClick.RemoveListener(OnApplyButtonClick); } private void OnNameChanged(string oldVal, string newVal) { nameMessageText.text = newVal; } private void OnNameInputChanged(string value) { viewModel.Name.Value = value; } private void OnJobChanged(string oldVal, string newVal) { jobMessageText.text = newVal; } private void OnJobInputChanged(string value) { viewModel.Job.Value = value; } private void OnApplyButtonClick() { resultText.text = viewModel.Name.Value + &quot;, &quot; + viewModel.Job.Value + &quot; have been saved&quot;; viewModel.SaveModel(); }} 程式碼： https://github.com/mystudybook/Unity-MVVM Reference: https://www.cnblogs.com/OceanEyes/p/unity3d_framework_designing_get_started_with_mvvm_part1.html","link":"/2024/06/09/2024-06-09-mvvm-pattern/"},{"title":"Unity MonoBehavior","text":"MonoBehaviour 是 Unity 中最重要的基類之一，用於控制遊戲物件(GameObject)的行為。並提供了一系列生命週期方法，這些方法在遊戲物件生命週期的不同階段會被調用。此外，還提供了一些輔助方法，用於執行常見任務，例如訪問遊戲物件和組件(Component)。 生命週期方法 (Lifecycle methods)MonoBehaviour 提供了一系列生命週期方法，這些方法在遊戲物件生命週期的不同階段會被調用。這些方法包括 Awake：此方法在遊戲物件(GameObject)實體被建立時呼叫一次。 通常用來：在APP開始前初始化遊戲物件狀態和屬性，例如設置變量、添加組件(Component)等。 Unity會在所有啟用的遊戲物件都實體化之後，才呼叫Awake，所以可以呼叫FindWithTag，而不用擔心找不到啟用的遊戲物件。 Awake不可以使用協程(Awake cannot act as a coroutine) 注意：Unity 不會保證用特定的順序調用每個遊戲物件的 Awake 方法。因此，不可以假設一個遊戲物件的 Awake 方法會在另一個遊戲物件的 Awake方法之前或之後調用。 正確的方式是在 Awake 中設置自身的屬性和取得其他物件的引用，而在 Start 方法中處理需要依賴其他遊戲物件的屬性和引用。 注意：如果如果遊戲物件是啟用(Enable)但是腳本(Script)並沒有被啟用，Awake依然會被執行。 OnEnable：啟用時才會呼叫，在Awake之後執行，每次啟用都會呼叫 通常在此註冊事件 Start：此方法在遊戲物件的所有組件都已初始化且第一幀渲染之前調用一次。 當這個遊戲物件處於 Disabled 就不會呼叫，直到該物件第一次被啟用時，才呼叫。 通常用來：處理開始遊戲物件開始的遊戲邏輯。 是在Awake與OnEnable之後呼叫 Start可以使用協程 (Coroutine) Update：此方法在遊戲的每一幀調用。 當物件為啟用時才會呼叫Update 通常用來：更新遊戲物件的狀態和處理使用者輸入。 FixedUpdate：此方法在固定的時間間隔調用，通常每 0.02 秒調用一次。 通常用來：在此方法更新遊戲物件的物理模擬。 當使用剛體(Rigidbody)的時候，最好在FixedUpdate中操作 LateUpdate：此方法在所有的 Update 方法之後調用。 它是更新依賴於 Update 方法結果的遊戲邏輯的理想場所。 例如：攝影機跟隨(follow camera)就很適合放在此，因為它需要跟隨那些可能在 Update 中已經移動過的物件。 OnDisable：與OnEnable類似，但是是非啟用時才會呼叫，每次非啟用都會呼叫 通常在此取消註冊事件 當遊戲物件為disable時，不會呼叫Update，FixedUpdate，LateUpdate等相關更新方法。 當遊戲物件為disable時，物件仍然在場景(Scene)中，該物件仍不會被釋放。 OnDestroy：此方法在遊戲物件被銷毀時調用一次。物件從場景(Scene)中被移除了，該物件所佔用的記憶體可以被釋放。 當原先場景關閉，載入新的場景時，也會觸發OnDestroy方法 通常用來：清理遊戲物件使用的資源。 如果如果遊戲物件是啟用(Enable)但是腳本(Script)並沒有被啟用，移除該物件時，OnDestroy依然會被執行。 注意：如果使用者是在手機平台上，那麼當使用者暫停你的APP時，作業系統(OS)可能會終止你的APP，而不會觸發 OnDestroy 方法，因此不要依賴此方法來保存APP的狀態。請將每次應用程序失去焦點視為APP退出，並使用 MonoBehaviour.OnApplicationFocus 來保存資料。 注意：在Unity中預設是不會控制Script的執行順序，Unity的執行會先將所有腳本的Awake執行完之後，才去執行所有腳本的Start，如果真的需要依賴順序你需要到ProjectSetting中的Script Exceution Order去設定順序，數字越小的越先執行。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354using System.Collections;using System.Collections.Generic;using UnityEngine;public class A : MonoBehaviour{ // 最先呼叫 private void Awake() { Debug.Log($&quot;{nameof(A)} is Awake&quot;); } // 啟用時才會呼叫，在Awake之後執行，每次啟用都會呼叫 private void OnEnable() { Debug.Log($&quot;{nameof(A)} is OnEnable&quot;); } // 在第一幀開始前執行 void Start() { Debug.Log($&quot;{nameof(A)} is Start&quot;); } // 每一幀執行 void Update() { Debug.Log($&quot;{nameof(A)} is Update&quot;); } // 在 Update 之後執行，也是每一幀執行 private void LateUpdate() { Debug.Log($&quot;{nameof(A)} is LateUpdate&quot;); } // 固定時間呼叫 private void FixedUpdate() { Debug.Log($&quot;{nameof(A)} is FixedUpdate&quot;); } // 非啟用時才會呼叫，每次非啟用都會呼叫 private void OnDisable() { Debug.Log($&quot;{nameof(A)} is OnDisable&quot;); } // 目前Component銷毀時才會呼叫 private void OnDestroy() { Debug.Log($&quot;{nameof(A)} is OnDestroy&quot;); }} Reference: https://docs.unity3d.com/ScriptReference/MonoBehaviour.Awake.html https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnEnable.html https://docs.unity3d.com/ScriptReference/MonoBehaviour.Start.html https://docs.unity3d.com/ScriptReference/MonoBehaviour.FixedUpdate.html https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnDisable.html https://docs.unity3d.com/ScriptReference/MonoBehaviour.OnDestroy.html","link":"/2024/06/11/2024-06-11-unity-MonoBehaviour/"},{"title":"在前端直接將檔案上傳到AWS S3","text":"在自己架設的伺服器中，如果要把檔案上傳到AWS S3，一種常見的做法是先將檔案上傳到自身伺服器然後再上傳到AWS S3，但是這樣太耗費資源了。幸好AWS S3有方式可以讓你在前端直接將檔案上傳到S3中，以下說明如何設定前端的HTML，讓檔案直接上傳。 首先你要有可以存取Bucket的 AWSAccessKeyId 與 AWSSecretAccessKey 以下資料皆來自https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-post-example.html AWSAccessKeyId AKIAIOSFODNN7EXAMPLE AWSSecretAccessKey wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY Bucket sigv4examplebucket HTML FORM以下是HTML Form的例子 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 將form的 action ，設為 action=&quot;https://&lt;你的Bucket名稱&gt;.s3.amazonaws.com/&quot; ， 如下--&gt; &lt;form action=&quot;http://sigv4examplebucket.s3.amazonaws.com/&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; Key to upload: &lt;!-- 這個 key 將設定 S3 Object Key， 例如設為： user/user1/myfile.csv，之後在AWS S3上面看到的就是 user/user1/myfile.csv --&gt; &lt;input type=&quot;input&quot; name=&quot;key&quot; value=&quot;user/user1/myfile.csv&quot; /&gt;&lt;br /&gt; &lt;!-- 這個 acl 將設定 S3 ACL， 如設為：public-read 表示可以被公開讀取，也可以設為 private ，表示是私有的--&gt; &lt;input type=&quot;hidden&quot; name=&quot;acl&quot; value=&quot;public-read&quot; /&gt; &lt;!-- 這個 success_action_redirect 將設定 上傳成功之後，要導向到哪個網頁，如設為：http://localhost:8080/uploaded.html --&gt; &lt;input type=&quot;hidden&quot; name=&quot;success_action_redirect&quot; value=&quot;http://localhost:8080/uploaded.html&quot; /&gt; Content-Type: &lt;!-- 這個 Content-Type 將限定要上傳的檔案類型，可以不設定 --&gt; &lt;!-- &lt;input type=&quot;input&quot; name=&quot;Content-Type&quot; value=&quot;image/jpeg&quot; /&gt;&lt;br /&gt; --&gt; &lt;!-- 這個 x-amz-meta-uuid 應由後端產生一組隨機的字串，讓AWS S3做驗證 --&gt; &lt;input type=&quot;hidden&quot; name=&quot;x-amz-meta-uuid&quot; value=&quot;14365123651274&quot; /&gt; &lt;!-- 這個 x-amz-server-side-encryption 說明使用哪種加密方式，例如 AES256 --&gt; &lt;input type=&quot;hidden&quot; name=&quot;x-amz-server-side-encryption&quot; value=&quot;AES256&quot; /&gt; &lt;!-- 這個 X-Amz-Credential 由 &lt;AWSAccessKeyId&gt;/&lt;日期&gt;/&lt;Bucket-Region&gt;/&lt;RegionService&gt;/&lt;Signing&gt; 組成，RegionService和Signing是固定的就是s3和aws4_request--&gt; &lt;input type=&quot;text&quot; name=&quot;X-Amz-Credential&quot; value=&quot;AKIAIOSFODNN7EXAMPLE/20151229/us-east-1/s3/aws4_request&quot; /&gt; &lt;!-- 這個 X-Amz-Algorithm說明建立這個Request的簽名使用哪種演算法，例如 AWS4-HMAC-SHA256 --&gt; &lt;input type=&quot;text&quot; name=&quot;X-Amz-Algorithm&quot; value=&quot;AWS4-HMAC-SHA256&quot; /&gt; &lt;!-- 這個 X-Amz-Date 說明建立這個Request的簽名的日期，為可選的，需要為 ISO 8601 basic format (YYYYMMDD'T'HHMMSS'Z') 格式 --&gt; &lt;input type=&quot;text&quot; name=&quot;X-Amz-Date&quot; value=&quot;20151229T000000Z&quot; /&gt; Tags for File: &lt;!-- 這個 x-amz-meta-tag 是可選的 --&gt; &lt;!-- &lt;input type=&quot;input&quot; name=&quot;x-amz-meta-tag&quot; value=&quot;&quot; /&gt;&lt;br /&gt; --&gt; &lt;!-- 這個 Policy 為Base64編碼的字串，在下面說明 --&gt; &lt;input type=&quot;hidden&quot; name=&quot;Policy&quot; value='&lt;Base64-encoded policy string&gt;' /&gt; &lt;!-- 這個 X-Amz-Signature 是簽名，包含AWSSecretAccessKey的值，應由後端產生，在下面說明 --&gt; &lt;input type=&quot;hidden&quot; name=&quot;X-Amz-Signature&quot; value=&quot;&lt;signature-value&gt;&quot; /&gt; File: &lt;input type=&quot;file&quot; name=&quot;file&quot; /&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;Upload to Amazon S3&quot; /&gt; &lt;/form&gt; &lt;/html&gt; POST PolicyPOST Policy 應由後端產生，他是一個JSON物件，以下是一個例子 123456789101112131415{ &quot;expiration&quot;: &quot;2015-12-30T12:00:00.000Z&quot;, &quot;conditions&quot;: [ {&quot;bucket&quot;: &quot;sigv4examplebucket&quot;}, [&quot;starts-with&quot;, &quot;$key&quot;, &quot;user/user1/&quot;], {&quot;acl&quot;: &quot;public-read&quot;}, {&quot;success_action_redirect&quot;: &quot;http://localhost:8080/uploaded.html&quot;}, // [&quot;starts-with&quot;, &quot;$Content-Type&quot;, &quot;image/&quot;], {&quot;x-amz-meta-uuid&quot;: &quot;14365123651274&quot;}, {&quot;x-amz-server-side-encryption&quot;: &quot;AES256&quot;}, // [&quot;starts-with&quot;, &quot;$x-amz-meta-tag&quot;, &quot;&quot;], {&quot;x-amz-credential&quot;: &quot;AKIAIOSFODNN7EXAMPLE/20151229/us-east-1/s3/aws4_request&quot;}, {&quot;x-amz-algorithm&quot;: &quot;AWS4-HMAC-SHA256&quot;}, {&quot;x-amz-date&quot;: &quot;20151229T000000Z&quot; } ]} expiration 表示這個上傳的Request可用的期限 conditions 設定條件，在檔案上傳前AWS S3會檢查一下，是否和HTML Form中的相符合 bucket Bucket 名稱，此範例為 sigv4examplebucket “starts-with”, “$key” 要放在這個Bucket的 Prefix，此範例為user/user1/ ，在HTML Form中的 key 需要符合在此設定的前綴祠才可以，如 user/user1/myfile.csv acl 設定 S3 ACL， 如設為：public-read 表示可以被公開讀取，也可以設為 private ，表示是私有的 success_action_redirect 上傳成功之後，要導向到哪個網頁，如設為：http://localhost:8080/uploaded.html x-amz-meta-uuid 後端產生的UUID x-amz-server-side-encryption 說明使用哪種加密方式， AES256 “starts-with”, “$Content-Type” 上傳的 content type，可以不設定 x-amz-credential 由 /&lt;日期&gt;/// 組成，RegionService和Signing是固定的就是s3和aws4_request x-amz-algorithm 說明建立這個Request的簽名使用哪種演算法，例如 AWS4-HMAC-SHA256 x-amz-date 建立這個Request的簽名的日期，為可選的，需要為 ISO 8601 basic format (YYYYMMDD’T’HHMMSS’Z’) 格式 注意，如果你在HTML Form中沒有設定某些參數，那麼在Policy中也不要設定，例如我在HTML Form中沒有設定 [&quot;starts-with&quot;, &quot;$Content-Type&quot;, &quot;image/&quot;] 和 [&quot;starts-with&quot;, &quot;$x-amz-meta-tag&quot;, &quot;&quot;]，那麼在 Policy中也不要設定。 之後由後端使用Base64將這段字串編碼， 1234567891011121314151617JSONObject j = new JSONObject();j.put(&quot;expiration&quot;, &quot;2015-12-30T12:00:00.000Z&quot;);j.put(&quot;conditions&quot;, new JSONArray() .put(new JSONObject().put(&quot;bucket&quot;, &quot;sigv4examplebucket&quot;)) .put(new JSONArray().put(&quot;starts-with&quot;).put(&quot;$key&quot;).put(&quot;user/user1/&quot;)) .put(new JSONObject().put(&quot;acl&quot;, &quot;private&quot;)) .put(new JSONObject().put(&quot;success_action_redirect&quot;, &quot;http://localhost:8080&quot;)) .put(new JSONObject().put(&quot;x-amz-meta-uuid&quot;, &quot;14365123651274&quot;)) .put(new JSONObject().put(&quot;x-amz-server-side-encryption&quot;, &quot;AES256&quot;)) .put(new JSONObject().put(&quot;x-amz-credential&quot;, &quot;AKIAIOSFODNN7EXAMPLE/20151229/us-east-1/s3/aws4_request&quot;)) .put(new JSONObject().put(&quot;x-amz-algorithm&quot;, &quot;AWS4-HMAC-SHA256&quot;)) .put(new JSONObject().put(&quot;x-amz-date&quot;, &quot;20151229T000000Z&quot;)));// 這個 Policy 就是要放在 HTML Form 中的 PolicyString policy = Base64.getEncoder().encodeToString(j.toString().getBytes()); Signature最後產生 Signature ，Java 可以直接使用有人提供的產生方式，來自 https://gist.github.com/phstudy/3523576726d74a0410f8 12345678910// 在 AccessSecretKey前面要加上 AWS4String accessSecretKey = &quot;AWS4&quot; + &quot;wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY&quot;;String date = &quot;20151229&quot;;String region = &quot;us-east-1&quot;;String regionService = &quot;s3&quot;;String signing = &quot;aws4_request&quot;;String stringToSign = policy;// 這個 signature 字串，就是要放在 HTML Form 中的 X-Amz-SignatureString signature = getSignatureV4(accessSecretKey, date, region, regionService, signing, stringToSign); 以上動作完成之後，還需要為你的Bucket設定 Cross-origin resource sharing (CORS) 12345678910111213141516[ { &quot;AllowedHeaders&quot;: [ &quot;*&quot; ], &quot;AllowedMethods&quot;: [ &quot;POST&quot;, &quot;GET&quot;, &quot;PUT&quot; ], &quot;AllowedOrigins&quot;: [ &quot;http://www.mywebsite.com/&quot; ], &quot;ExposeHeaders&quot;: [] }] 如果是測試的話，可以先將Chrome的web-security關閉，Mac使用以下指令 1open -n -a &quot;Google Chrome&quot; --args --user-data-dir=/tmp/temp_chrome_user_data_dir http://localhost:8080/ --disable-web-security Reference: https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-post-example.html https://docs.aws.amazon.com/directconnect/latest/APIReference/CommonParameters.html https://gist.github.com/phstudy/3523576726d74a0410f8 https://stackoverflow.com/questions/3102819/disable-same-origin-policy-in-chrome","link":"/2024/06/13/2024-06-13-browser-base-upload-to-aws-s3/"},{"title":"關閉 Chrome的 Web Security","text":"在前後端分離的狀況下，很容易就會遇到跨域的問題，為了開發測試方便，我們可以暫時禁用Chrome的安全設定，以方便我們測試開發。 在Mac上使用以下指令來關閉 Chrome的安全設定 1open -n -a &quot;Google Chrome&quot; --args --user-data-dir=/tmp/temp_chrome_user_data_dir http://localhost:8080/ --disable-web-security 當出現 你正在使用不受支援的命令列標嫩：--disable-web-security•這可能會危及穩定性與安全性。 字樣，表示你已經成功關閉Chrome的安全設定了。 Reference: https://stackoverflow.com/questions/3102819/disable-same-origin-policy-in-chrome","link":"/2024/06/13/2024-06-13-disable-web-security/"},{"title":"Actions","text":"Action是將裝置控制(device control)與輸入(input)分開的一個重要概念。舉例來說，某個遊戲中某些輸入(input)的目的是讓遊戲角色移動，而與該動作(Action)相關的裝置控制(device control)可能是左搖桿。將動作(action)與執行這個輸入的裝置控制(左搖桿)關聯起來的稱作綁定(Binding)。你可以在Action Editor中建立這種綁定，當在程式碼中使用Actons時，你不需要去指定特定的裝置，因為Binding定義了哪些裝置可以執行這個Action。 透過Action Editor你可以為Action建立多個設備的對應，例如下圖，Move對應了鍵盤與遊戲搖桿，之後你就可以在程式碼中取得這個Action的參考，並可以檢查它的值，或是為它附加callback方法 12// 透過InputSystem API可以找到Move，注意不要在Update loop中使用，因為它是基於字串搜尋，因此會影響效能InputAction moveAction = InputSystem.actions.FindAction(&quot;Move&quot;); 注意： Action只可在runtime使用，不可以在Edit Window code中使用。 也可以不使用Action和Binding來直接取得裝置控制的值var gamepad = Gamepad.current;，但是彈性會比較差。 Action Editor 中顯示的動作順序僅供視覺參考，並不代表實際程式碼執行的順序。多個動作可能在同一幀中執行，Input system的動作順序是不確定的。為了避免潛在問題，請勿在程式碼中假設動作會按特定順序執行。 當您在InputSystem中使用Action進行Script編寫時，可以利用以下一些重要的API， API 名稱 描述 InputAction 一個命名Action，它可以回傳與其綁定的裝置控制的值，或是觸發callback。這個API就是Action Editor中Action那一欄的值 InputActionMap 命名的Action集合。這個API持有的集合就是Action Editor中Action Map那一欄的值 InputSystem.actions 是一個專案範圍內動作集合(ProjectWideActions)的引用(reference) InputBinding 動作(Action)與其接收輸入的特定設備控制(device control)之間的關係，ActionBindings Action：每個Action都有一個名稱(InputAction.name)，在一個Action Map中，這個Action的名稱必須是獨一無二的，每個Action也會有一個獨一無二的ID(InputAction.id)，可以用它們來找到這個Action的引用。當ID產生之後，就算名稱改變ID也不會變。 Action Map：每個Action Map都有一個名稱(InputActionMap.name)，這個Action Map的名稱必須是獨一無二的，每個Action Map也會有一個獨一無二的ID(InputActionMap.id)，可以用它們來找到這個Action Map的引用。當ID產生之後，就算名稱改變ID也不會變。 建立Action建立Action有好幾種方式 方法一：使用Action Editor建立Action：最簡單的方式是使用Action Editor建立 方法二：在MonoBehaviours中宣告Action，此方法與方法一類似，差異在於它將Actions定義在GameObject的屬性中，並儲存為Scene或是Prefab。並且它不是project-wide action，因此在使用時需要手動的啟用，停用這些Action。12345678using UnityEngine;using UnityEngine.InputSystem;public class ExampleScript : MonoBehaviour{ public InputAction move; public InputAction jump;} 方法三：在JSON中載入12345// Load a set of action maps from JSON.var maps = InputActionMap.FromJson(json);// Load an entire InputActionAsset from JSON.var asset = InputActionAsset.FromJson(json); 方法四：使用程式碼123456789101112131415161718192021// Create free-standing Actions.var lookAction = new InputAction(&quot;look&quot;, binding: &quot;&lt;Gamepad&gt;/leftStick&quot;);var moveAction = new InputAction(&quot;move&quot;, binding: &quot;&lt;Gamepad&gt;/rightStick&quot;);lookAction.AddBinding(&quot;&lt;Mouse&gt;/delta&quot;);moveAction.AddCompositeBinding(&quot;Dpad&quot;) .With(&quot;Up&quot;, &quot;&lt;Keyboard&gt;/w&quot;) .With(&quot;Down&quot;, &quot;&lt;Keyboard&gt;/s&quot;) .With(&quot;Left&quot;, &quot;&lt;Keyboard&gt;/a&quot;) .With(&quot;Right&quot;, &quot;&lt;Keyboard&gt;/d&quot;);// Create an Action Map with Actions.var map = new InputActionMap(&quot;Gameplay&quot;);var lookAction = map.AddAction(&quot;look&quot;);lookAction.AddBinding(&quot;&lt;Gamepad&gt;/leftStick&quot;);// Create an Action Asset.var asset = ScriptableObject.CreateInstance&lt;InputActionAsset&gt;();var gameplayMap = new InputActionMap(&quot;gameplay&quot;);asset.AddActionMap(gameplayMap);var lookAction = gameplayMap.AddAction(&quot;look&quot;, &quot;&lt;Gamepad&gt;/leftStick&quot;); 對於非專案範圍(project-wide)的Actions，在使用前需要先啟用(Enable) 12345// 啟用單一actionlookAction.Enable();// 啟用整個action map.gameplayActions.Enable(); 當您啟用一個「動作」(Action)時，InputSystem會解析其綁定(bindings)。啟用後，「動作」會積極監控其綁定的「控件」(Control(s))。如果綁定的「控件」狀態改變，「動作」就會處理該變化。如果「控件」的變化代表「交互」(Interaction) 變化，則「動作」會創建一個響應。所有這些都發生在輸入系統的更新邏輯中。取決於輸入設置中選擇的「更新模式」，這可能每幀發生一次，每固定更新一次，或者如果更新設置為手動，則手動發生一次。 在「動作」啟用的情況下，有些配置無法更改，例如「動作綁定」。要停止Action或Action Map響應輸入，可以使用「停用」(Disable)方法。 上一篇：使用Action Editor編輯Action 下一篇：使用Action Reference: https://docs.unity3d.com/Packages/com.unity.inputsystem@1.8/manual/Actions.html","link":"/2024/04/25/Actions/"},{"title":"C# 明確方式實作介面","text":"明確方式實作介面(Explicit Interface Implementation)如果一個class去實作兩個有相同方法的interface，會發生什麼事？程式如下，分別有兩個interface IControl 與 IAction都含有Move()方法，其中ExampleClass去實作這兩個Interface。 12345678910111213141516public interface IControl{ void Move();}public interface IAction{ void Move();}public class ExampleClass : IControl, IAction{ // Both IAction.Move and IControl.Move call this method. public void Move() { Console.WriteLine(&quot;Move method in ExampleClass&quot;); }} 執行 12345678910111213ExampleClass example = new ExampleClass();IControl control = example;IAction action = example;// The following lines all call the same method.example.Move();control.Move();action.Move();// Output:// Move method in ExampleClass// Move method in ExampleClass// Move method in ExampleClass 結果是都會呼叫同一個實作。 但是你可能希望個自Interface執行不同的實作，這時就可以使用Explicit Interface Implementation如下： 1234567891011public class ExampleClass2 : IControl, IAction{ void IControl.Move() { System.Console.WriteLine(&quot;IControl.Move&quot;); } void IAction.Move() { System.Console.WriteLine(&quot;IAction.Move&quot;); }} 執行 123456789101112ExampleClass2 example2 = new ExampleClass2();IControl control = example2;IAction action = example2;// The following lines all call the same method.//example2.Move(); // Compiler error.control.Move(); // Calls IControl.Move on ExampleClass2.action.Move(); // Calls IAction.Move on ExampleClass2.// Output:// IControl.Move// ISurface.Move 此時，不可以直接透過實作class的物件去直接呼叫，會出現編譯錯誤，必須要把該物件轉換為對應的interface，例如如果你想呼叫IControl的Move方法，那麼就把它轉換為IControl。 注意：Explicit Interface Implementation是沒有存取修飾詞的，因為它無法當做其定義類型的成員來存取。它只有在透過interface的執行個體呼叫時才能存取。 參考：https://learn.microsoft.com/zh-tw/dotnet/csharp/programming-guide/interfaces/explicit-interface-implementation","link":"/2024/02/05/C-%E6%98%8E%E7%A2%BA%E6%96%B9%E5%BC%8F%E5%AF%A6%E4%BD%9C%E4%BB%8B%E9%9D%A2/"},{"title":"碰撞器(Collider)","text":"剛體(Rigidbody)賦予了物件可以接受力，而碰撞器(Collider)則賦予物件碰撞的形狀(edit collider)，以及是否可以會其他物件碰撞，越複雜形狀的碰撞器越耗效能。 參數簡介 Is Trigger：是否是觸發器，如果啟用則該collider將用於觸發事件，並被物理引擎忽略，主要用於進行沒物理效果的碰撞檢測 Material：物理材質，可以確定碰撞體和其他物件碰撞時的交互方式 Center：碰撞體在物件局部中的中心點位置","link":"/2024/04/03/Collider%E7%A2%B0%E6%92%9E%E5%99%A8/"},{"title":"DELETE與TRUNCATE的區別","text":"DELETE與TRUNCATE的區別 DELETE 是DML語句，可以ROLLBACK， 可以有條件的刪除 如果刪除較大量的資料，DELETE效率較差 TRUNCATE 是DDL語句，立即生效，無法ROLLBACK TRUNCATE將TABLE中的資料全部刪除 如果刪除較大量的資料TRUNCATE效率較好","link":"/2024/02/08/DELETE%E8%88%87TRUNCATE%E7%9A%84%E5%8D%80%E5%88%A5/"},{"title":"Command Pattern","text":"命令模式(Command Pattern)：當你想要追蹤一系列特定動作時，可以使用命令模式（command pattern）。如果你玩過帶有撤銷(undo)/重做(redo)功能或是能夠在列表中保留輸入歷史的遊戲，你很可能已經見過命令模式。想像一個策略遊戲，玩家可以在實際執行之前計劃多個動作，這就是命令模式。 在設計模式中，命令模式有以下角色參與其中 Command：抽象命令，可能為一個介面(Interface)或是抽象類(Abstract Class)，例如ICommand ConcreteCommand：具體命令，即實作抽象命令的Class Invoker：命令的調用者，發起者，管理者 Receiver：接收者，實際執行命令者，被Command訪問與操作 使用命令的客戶端(Client) 命令模式特點： 命令模式不直接呼叫方法(method)而是會將單個或多個方法封裝為命令物件(command object)。 命令物件會存放到一個容器(像是Stack或是Queue)中，讓你可以在想要的時間點去執行或是撤銷這些命令物件。 新增命令不會影響其他地方，符合了開閉原則(Open-closed principle) 除了撤銷(undo)/重做(redo)功能，也可以用來實現回放(Play back)功能 接收者(Receiver)類：PlayerMover，在命令物件執行時真正執行動作。 123456789101112131415161718192021222324public class PlayerMover : MonoBehaviour{ [SerializeField] private LayerMask obstacleLayer; private const float boardSpacing = 1f; private PlayerPath playerPath; public PlayerPath PlayerPath =&gt; playerPath; private void Start() { playerPath = gameObject.GetComponent&lt;PlayerPath&gt;(); } public void Move(Vector3 movement) { Vector3 destination = transform.position + movement; transform.position = destination; } public bool IsValidMove(Vector3 movement) { return !Physics.Raycast(transform.position, movement, boardSpacing, obstacleLayer); }} 定義一個抽象命令介面(ICommand) 12345public interface ICommand{ void Execute(); void Undo();} 定義一個具體命令 1234567891011121314151617181920212223public class MoveCommand : ICommand{ private PlayerMover _playerMover; private Vector3 _movement; public MoveCommand(PlayerMover player, Vector3 moveVector) { this._playerMover = player; this._movement = moveVector; } public void Execute() { _playerMover?.PlayerPath.AddToPath(_playerMover.transform.position + _movement); _playerMover.Move(_movement); } public void Undo() { _playerMover.Move(-_movement); _playerMover?.PlayerPath.RemoveFromPath(); }} 定義一個使用命令的命令调用者類CommandInvoker，它只負責執行(ExecuteCommand())和撤銷(UndoCommand())命令。 它含有一個容器(undoStack)，用來儲存一系列的命令。 當執行命令時，從容器中取出一個命令物件執行方法(Execute) 當撤消命令時，從容器中取出一個命令物件，並執行撤銷方法(Undo)1234567891011121314151617181920212223242526272829303132public class CommandInvoker{ private static Stack&lt;ICommand&gt; _undoStack = new Stack&lt;ICommand&gt;(); private static Stack&lt;ICommand&gt; _redoStack = new Stack&lt;ICommand&gt;(); public static void ExecuteCommand(ICommand command) { command.Execute(); _undoStack.Push(command); _redoStack.Clear(); } public static void UndoCommand() { if (_undoStack.Count &gt; 0) { ICommand activeCommand = _undoStack.Pop(); _redoStack.Push(activeCommand); activeCommand.Undo(); } } public static void RedoCommand() { if (_redoStack.Count &gt; 0) { ICommand activeCommand = _redoStack.Pop(); _undoStack.Push(activeCommand); activeCommand.Execute(); } }} 使用命令的客戶端(Client)類，InputManager，它透過CommandInvoker執行命令 123456789101112131415161718192021222324252627282930313233343536373839public class InputManager : MonoBehaviour{ [Header(&quot;Button Controls&quot;)] [SerializeField] Button forwardButton; [SerializeField] Button backButton; [SerializeField] Button leftButton; [SerializeField] Button rightButton; [SerializeField] Button undoButton; [SerializeField] Button redoButton; [SerializeField] private PlayerMover player; private void Start() { forwardButton.onClick.AddListener(OnForwardInput); backButton.onClick.AddListener(OnBackInput); rightButton.onClick.AddListener(OnRightInput); leftButton.onClick.AddListener(OnLeftInput); undoButton.onClick.AddListener(OnUndoInput); redoButton.onClick.AddListener(OnRedoInput); } private void RunPlayerCommand(PlayerMover playerMover, Vector3 movement) { if (playerMover == null) return; if (playerMover.IsValidMove(movement)) { ICommand command = new MoveCommand(playerMover, movement); CommandInvoker.ExecuteCommand(command); } } private void OnLeftInput() { RunPlayerCommand(player, Vector3.left); } private void OnRightInput() { RunPlayerCommand(player, Vector3.right); } private void OnForwardInput() { RunPlayerCommand(player, Vector3.forward); } private void OnBackInput() { RunPlayerCommand(player, Vector3.back); } private void OnUndoInput() { CommandInvoker.UndoCommand(); } private void OnRedoInput() { CommandInvoker.RedoCommand(); }} Reference: https://github.com/Unity-Technologies/game-programming-patterns-demo/tree/main/Assets/9%20Command","link":"/2024/05/25/Command-Pattern/"},{"title":"Dependency inversion principle","text":"依賴倒置原則(Dependency inversion principle)有兩個主要部分： 高層模組不應該依賴於低層模組。兩者都應該依賴於抽象。 抽象不應該依賴於具體實現。具體實現應該依賴於抽象。 在軟體設計中，如果一個類(class)使用了另一個類稱為依賴(dependency 或 coupling)，每增加一點依賴，就會增加一些風險，因為當某個類A知道了另一個類B的內容太多的話(稱為高度耦合high degree of coupling)，當B更改的話，那麼A也會需要大量的修改，這樣很容易產生錯誤。 在設計中，有些類是high-level的，而有些類是low-level的，high-level的類會依靠low-level的類去完成某些工作。我們在設計時，要考慮依賴倒置原則，減少一些耦合度。 如果要建立一個遊戲，其中角色可以探索房間，並使用開關(switch)將門(dor)打開，在實作時，你可能會想到要建立一個Switch類與一個Door類，其中 Switch屬於high-level的類，它負責判斷角色是否移動到對應的位置，並是否觸發對應的行為 Door屬於low-level的類，它負責開關門的實際操作邏輯 如果沒有使用依賴倒置原則的話，可能會如下實作 Switch依賴於Door，當條件觸發時，呼叫door去開門1234567891011121314151617181920212223242526272829303132public class Switch{ public Door door; public bool isActivated; public void Toggle() { if (isActivated) { isActivated = false; door.Close(); } else { isActivated = true; door.Open(); } }}public class Door{ public void Open() { Debug.Log(&quot;The door is open.&quot;); } public void Close() { Debug.Log(&quot;The door is closed.&quot;); }} 這樣的實作沒有問題，但是如果開關(Switch)不只是開門，還可能會觸發一些陷阱的話，就不得不去修改Switch類，這樣違反了開閉原則(Open-closed principle) 你可以將開關這個動作抽象=&gt;ISwitchable。 123456public interface ISwitchable{ bool IsActive { get; } void Activate(); void Deactivate();} 讓Door去實作這個抽象ISwitchable 1234567891011121314151617public class Door : MonoBehaviour, ISwitchable{ private bool isActive; public bool IsActive =&gt; isActive; public void Activate() { isActive = true; Debug.Log(&quot;The door is open.&quot;); } public void Deactivate() { isActive = false; Debug.Log(&quot;The door is closed.&quot;); }} 而Switch則依賴這個抽象ISwitchable 12345678910111213141516public class Switch : MonoBehaviour{ public ISwitchable client; public void Toggle() { if (client.IsActive) { client.Deactivate(); } else { client.Activate(); } }} 透過這種方式將上層對底層的依賴剝離至抽象，讓上層可以不需更改程式碼，只需傳入不同的ISwitch實作便可以做到開關不同的物件。","link":"/2024/05/22/Dependency-inversion-principle/"},{"title":"Runtime DataBinding(使用UI Builder)","text":"以下將示範如何使用UI Builder與ScriptableObject來建立DataBinding 在Unity編輯器中，建立一個Script 建立一個名為ExampleObject的ScriptableObject(檔案會是 ExampleObject.cs)，它包含了 一個string vector3Label， 一個Vector3 vector3Value 一個float sumOfVector3Properties，這個sumOfVector3Properties是一個readonly的屬性其值來自於vector3Label中的x，y與z之和， 一個float dangerLevel是一個 0 ~ 1之間的數值。之後在UI Builder中更改使用Value To Progress設定，讓它可以根據ConverterGroup顯示對應的值1234567891011121314151617181920212223242526272829303132333435363738394041using Unity.Properties;using UnityEditor;using UnityEngine;using UnityEngine.UIElements;[CreateAssetMenu]public class ExampleObject : ScriptableObject{ [InitializeOnLoadMethod] public static void RegisterConverters() { // Create local Converters var group = new ConverterGroup(&quot;Value To Progress&quot;); // Converter groups can have multiple converters. This example converts a float to both a color and a string. group.AddConverter((ref float v) =&gt; new StyleColor(Color.Lerp(Color.red, Color.green, v))); group.AddConverter((ref float value) =&gt; { return value switch { &gt;= 0 and &lt; 1.0f / 3.0f =&gt; &quot;Danger&quot;, &gt;= 1.0f / 3.0f and &lt; 2.0f / 3.0f =&gt; &quot;Neutral&quot;, _ =&gt; &quot;Good&quot; }; }); // Register the converter group in InitializeOnLoadMethod to make it accessible from the UI Builder. ConverterGroups.RegisterConverterGroup(group); } [Header(&quot;Bind to multiple properties&quot;)] public string vector3Label; public Vector3 vector3Value; [CreateProperty] public float sumOfVector3Properties =&gt; vector3Value.x + vector3Value.y + vector3Value.z; [Header(&quot;Binding using a converter group&quot;)] [Range(0, 1)] public float dangerLevel;} 在Unity編輯器中，選擇 Create &gt; Example Object ，建立一個Example Object並命名為Object1 (檔案會是 Object1.asset) 建立一個UXML，命名為ExampleObject(檔案會是ExampleObject.uxml) 點擊剛剛建立的ExampleObject.uxml，開啟UI Builder 在Hierarchy panel中，加入一個VisualElement 在剛剛建立的VisualElement中加入Vector3Field，FloatField與Label 最後Hierarchy panel畫面為 選擇最上層的VisualElement UI Element，在右邊找到Data Source，選擇之前建立的Object1.asset，這樣做，會將它的Child Elements都預設綁定Object1 選擇Vector3Field UI Element，在右邊找到Label，對Label按一下滑鼠右鍵，點選Add binding...，在Data Source Path中找到並選擇vector3Label，Binding Mode選擇To Target 接下來，對Vector3Field的Value按一下滑鼠右鍵，點選Add binding...，在Data Source Path中找到並選擇vector3Value，Binding Mode選擇To Target 選擇Float UI Element，在右邊找到Value按一下滑鼠右鍵，點選Add binding...，在Data Source Path中找到並選擇sumOfVector3Properties，Binding Mode選擇To Target 選擇Label UI Element， 在右邊找到Text，對Text按一下滑鼠右鍵，點選Add binding...，在Data Source Path中找到並選擇dangerLevel，Binding Mode選擇To Target 接著打開Advanced Settings 找到 Converters &gt; To target property (UI) 選擇 Value To Progress 接下來，在右邊找到Color，對Color按一下滑鼠右鍵，點選Add binding...，在Data Source Path中勾選Show only compatible之後才會出現可以選擇的相容屬性，選擇dangerLevel，Binding Mode選擇To Target 接著打開Advanced Settings 找到 Converters &gt; To target property (UI) 選擇 Value To Progress 至此，這個UI與 ExampleObject的綁定就算完成了，UXML可能會為123456789101112131415161718192021222324&lt;engine:UXML xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:engine=&quot;UnityEngine.UIElements&quot; xmlns:editor=&quot;UnityEditor.UIElements&quot; noNamespaceSchemaLocation=&quot;../../../UIElementsSchema/UIElements.xsd&quot; editor-extension-mode=&quot;False&quot;&gt; &lt;engine:VisualElement data-source=&quot;project://database/Assets/UI/Custom/Object1.asset?fileID=11400000&amp;amp;guid=a0e72bbf894f04543b805067235fe91c&amp;amp;type=2#Object1&quot; style=&quot;flex-grow: 1;&quot;&gt; &lt;engine:Vector3Field name=&quot;Vector3Field&quot; focusable=&quot;false&quot;&gt; &lt;Bindings&gt; &lt;engine:DataBinding property=&quot;label&quot; binding-mode=&quot;ToTarget&quot; data-source-path=&quot;vector3Label&quot; /&gt; &lt;engine:DataBinding property=&quot;value&quot; binding-mode=&quot;ToTarget&quot; data-source-path=&quot;vector3Value&quot; /&gt; &lt;/Bindings&gt; &lt;/engine:Vector3Field&gt; &lt;engine:FloatField label=&quot;Float Field&quot; name=&quot;FloatField&quot;&gt; &lt;Bindings&gt; &lt;engine:DataBinding property=&quot;value&quot; binding-mode=&quot;ToTarget&quot; data-source-path=&quot;sumOfVector3Properties&quot; /&gt; &lt;engine:DataBinding property=&quot;text&quot; binding-mode=&quot;ToTarget&quot; data-source-path=&quot;dangerLevel&quot; source-to-ui-converters=&quot;Value To Progress&quot; /&gt; &lt;engine:DataBinding property=&quot;text&quot; binding-mode=&quot;ToTarget&quot; data-source-path=&quot;dangerLevel&quot; source-to-ui-converters=&quot;Value To Progress&quot; /&gt; &lt;/Bindings&gt; &lt;/engine:FloatField&gt; &lt;engine:Label text=&quot;Label&quot; name=&quot;Label&quot; enable-rich-text=&quot;false&quot; parse-escape-sequences=&quot;true&quot;&gt; &lt;Bindings&gt; &lt;engine:DataBinding property=&quot;value&quot; binding-mode=&quot;ToTarget&quot; data-source-path=&quot;sumOfVector3Properties&quot; /&gt; &lt;engine:DataBinding property=&quot;text&quot; binding-mode=&quot;ToTarget&quot; data-source-path=&quot;dangerLevel&quot; source-to-ui-converters=&quot;Value To Progress&quot; /&gt; &lt;engine:DataBinding property=&quot;text&quot; binding-mode=&quot;ToTarget&quot; data-source-path=&quot;dangerLevel&quot; source-to-ui-converters=&quot;Value To Progress&quot; /&gt; &lt;/Bindings&gt; &lt;/engine:Label&gt; &lt;/engine:VisualElement&gt;&lt;/engine:UXML&gt; 可以調整Object1來觀察UI的變化 結果 Reference: https://docs.unity3d.com/2023.2/Documentation/Manual/UIE-get-started-runtime-binding.html","link":"/2024/05/07/DataBinding-%E4%BD%BF%E7%94%A8UI-Builder/"},{"title":"Eclipse 在開啟時卡在Maven build的解決方法","text":"如果開啟Eclipse時，發現會卡住，打不開，而關閉Eclipse時，顯示Maven build的訊息，卡住Eclipse，如圖：以下是處理步驟： 先將Eclipse關閉，如果關不掉，使用強制關閉的方式關閉。 然後移動到程式碼放置的位置，找到.metadata資料夾，把它移走，放到別的地方，（或者是直接刪除） 之後再開啟Eclipse，然後在重新import專案。 這時Eclipse會自動重新建立專案。","link":"/2024/02/08/Eclipse-%E5%9C%A8%E9%96%8B%E5%95%9F%E6%99%82%E5%8D%A1%E5%9C%A8Maven-build%E7%9A%84%E8%A7%A3%E6%B1%BA%E6%96%B9%E6%B3%95/"},{"title":"分派事件(Dispatch event)","text":"事件分派器(Event Dispacther)UI Toolkit有一個Event System它負責監聽事件，這些事件可能來自OS或是Scripts，當事件發生時，EventDispatcher會使用最適合的分派策略(appropriate dispatching strategy)將事件分派給對應的visual elements。 Visual elements對於一些預設行為以實作多個事件，這些事件在建立，執行時可能會產生一些額外的事件，例如：MouseMoveEvent會連帶產生一個MouseEnterEvent與一個MouseLeaveEvent，這些事件會被放入一個Queue中，當目前的事件處理完之後在依序處理。(MouseMoveEvent處理完之後才處理連帶產生MouseEnterEvent與MouseLeaveEvent) 分派行為(Dispatch Behavior)每種Event類型都有它自己的分派行為(dispatch behavior)，這些行為(behavior)可以被分為三個階段(stage)： Trickles down: 事件會在這個Trickles down階段發送給element Bubbles up: 事件會在這個Bubble-up階段發送給element Cancellable: 事件取消(execution cancelled)，停止(stopped)或是阻止(prevented）自己原先的動作。 事件傳播(Event propagation)事件分派器(event dispatcher)在選好事件目標(event target)之後，就會開始計算這個事件的傳播路徑(propagation path)，傳播路徑是一個list，這個list為會收到該事件的Visual elements組成，且這些Elements是經過排序的。傳播路徑發生的順序： trickle-down phase：路徑從visual element tree的root visual element開始往下延伸(descends)，直到找到事件目標(event target)，這個過程稱為trickle-down phase 事件目標(event target)接收到事件 bubble-up phase：事件沿著tree往上延伸(ascends)直到root element，這個過程稱為bubble-up phase 事件傳播時，會根據不同的type有不同的行為， 例如有些event types會忽略bubble-up phase，有些event types只會發送給event target。 此外，假設有個element被隱藏(hide)或是(停用)disable，那麼這個element就不會收到事件，但是祖先(ancestors)與子孫(descendants)傳播 事件目標(Event Target)事件的目標是根據event type而定，例如滑鼠事件(mouse event)它的目標一般來說都是最上層被點擊的element；而鍵盤事件(keyboard event)它的目標則是有焦點(focus)的element。 Event.target：UI Toolkit的events都有一個target屬性，它持有事件發生element的參考(reference)，此外這個Event.target在分派處理(dispatch process)時是不會改變的。 Event.currentTarget：Event.currentTarget存放目前正在處理event的visual element 滑鼠事件PickingMode：大部分的mouse event會使用picking mode來決定它們的target，VisualElement class有一個pickingMode屬性來做這件事，其中 PickingMode.Position (預設): 根據位置矩形(position rectangle)來挑選 PickingMode.Ignore: 防止被mouse event選到 此外，你可以override VisualElement.ContainsPoint()來自定挑選邏輯 Capture events：在MouseDownEvent之後，一些elements必須捕獲指標位置(pointer position)，以確保它接收到所有後續的滑鼠事件，即使游標不再懸停(hovering over)在該element上。例如，當你點擊button、slider或scroll bar時。 element.CaptureMouse()或是MouseCaptureController.CaptureMouse()可以獲取滑鼠。 MouseCaptureController.ReleaseMouse()會釋放滑鼠。 當某個element持有滑鼠時，另外一個element呼叫CaptureMouse()的話，原先持有滑鼠的element會收一個MouseCaptureOutEvent並失去滑鼠 應用程式中一次只能有一個element捕獲滑鼠。當一個element捕獲了滑鼠時，除了滑鼠滾輪事件(mouse wheel event)之外，它將成為所有後續滑鼠事件的target。(這僅適用於那些尚未設定target且依賴於分派過程來確定targer的滑鼠事件。) Focus Order：每個UI Toolkit panel都會有一個 focus ring，用來決定elements的focus order，預設是使用depth-first search(DFS)來決定 下圖中的focus order為F，B，A，D，C，E，G，I，H 有些events會使用focus order來決定來決定哪些element持有focus，例如鍵盤事件(keyboard event)的目標(target)就是具有焦點(focus)的element focusable屬性決定一個visual element是否為可聚焦的(focusable)。預設中，VisualElement不是focusable的，但它的一些子類(subclass)如TextField預設是focusable。 tabIndex屬性可以控制focus order， 預設tabIndex為零， 如果tabIndex為負數，則無法使用tab鍵來聚焦在該element上。 如果tabIndex為零，則由focus ring algorithm決定。 如果tabIndex為正數，則比該element小的element會先被聚焦，之後才是該element。 Reference：https://docs.unity3d.com/Manual/UIE-Events-Dispatching.html","link":"/2024/04/17/Dispatch-event/"},{"title":"Eclipse常用快速鍵","text":"以下是Eclipse常用快速鍵(shortcuts) 格式化程式碼(auto-format code)： Windows 或是 Linux : Ctrl + Shift + f Mac : ⇧ + ⌘ + f 轉為大寫(Upper case) Windows 或是 Linux : Ctrl + Shift + x Mac : ⌘ + ⇧ + x 轉為小寫(Lower case) Windows 或是 Linux : Ctrl + Shift + y Mac : ⌘ + ⇧ + y Reference: https://www.shortcutfoo.com/app/dojos/eclipse-mac/cheatsheet","link":"/2024/05/06/Eclipse%E5%B8%B8%E7%94%A8%E5%BF%AB%E9%80%9F%E9%8D%B5/"},{"title":"HTML 編碼解碼小工具","text":"","link":"/2024/02/08/HTML%E7%B7%A8%E7%A2%BC%E8%A7%A3%E7%A2%BC%E5%B0%8F%E5%B7%A5%E5%85%B7/"},{"title":"Factory pattern","text":"工廠模式(Factory pattern)：讓一個特別的物件(工廠Factory)去建立其他物件(產品Product)。它封裝了生成其他物件(產品Product)的邏輯，最直接可見的好處是整理了你的程式碼。工廠物件可以有多種子類(subclass)，用來產生多種不同的產品。 優點 使用工廠模式的好處是當你增加產品時，你不需要修改先前的程式碼就可以增加產品 缺點 增加程式碼的複雜度 建立一個IProduct介面，訂立產品必須要有的規則 每個產品一定要有自己的名字(ProductName) 每個產品有初始化自己的方式(Initialize()) 產品種類比較不會有共用的邏輯，因此將其設計為介面12345public interface IProduct{ public string ProductName { get; set; } public void Initialize();} 以下建立一個抽象工廠，抽象工廠用來規定工廠必須要有的動作 每個工廠必須要能在對應的位置(Vector3 position)上生產產品(GetProduct())123456public abstract class Factory : MonoBehaviour{ public abstract IProduct GetProduct(Vector3 position); // shared method with all factories …} 建立一個產品A 它含有一個ParticleSystem，並在初始化方法(Initialize)中會播放此ParticleSystem1234567891011121314public class ProductA : MonoBehaviour, IProduct{ [SerializeField] private string productName = &quot;ProductA&quot;; public string ProductName { get =&gt; productName; set =&gt; productName = value ; } private ParticleSystem particleSystem; public void Initialize() { // any unique logic to this product gameObject.name = productName; particleSystem = GetComponentInChildren&lt;ParticleSystem&gt;(); particleSystem?.Stop(); particleSystem?.Play(); }} 建立一個工廠A 它含有一個產品A的依賴，在GetProduct()方法中建立產品A實體之後，會呼叫產品A實體上的Initialize()方法用來初始化該實體。12345678910111213public class ConcreteFactoryA : Factory{ [SerializeField] private ProductA productPrefab; public override IProduct GetProduct(Vector3 position) { // 使用Prefab在指定的position上建立一個instance GameObject instance = Instantiate(productPrefab.gameObject, position, Quaternion.identity); ProductA newProduct = instance.GetComponent&lt;ProductA&gt;(); // 初始化產品A newProduct.Initialize(); return newProduct; }} 建立一個產品B 它含有一個AudioSource，在初始化方法(Initialize)中會播放此AudioSource12345678910111213141516public class ProductB : MonoBehaviour, IProduct{ [SerializeField] private string productName = &quot;ProductB&quot;; public string ProductName { get =&gt; productName; set =&gt; productName = value; } private AudioSource audioSource; public void Initialize() { // do some logic here audioSource = GetComponent&lt;AudioSource&gt;(); audioSource?.Stop(); audioSource?.Play(); }} 建立一個工廠B 工廠B與工廠A類似，不過依賴換為產品B123456789101112131415161718192021public class ConcreteFactoryB : Factory{ // used to create a Prefab [SerializeField] private ProductB productPrefab; public override IProduct GetProduct(Vector3 position) { // create a Prefab instance and get the product component GameObject instance = Instantiate(productPrefab.gameObject, position, Quaternion.identity); ProductB newProduct = instance.GetComponent&lt;ProductB&gt;(); // each product contains its own logic newProduct.Initialize(); // add any unique behavior to this factory instance.name = newProduct.ProductName; Debug.Log(GetLog(newProduct)); return newProduct; }} 建立一個使用工廠的類 ClickToCreate這個類使用了工廠A與工廠B，1234567891011121314151617181920212223242526272829303132public class ClickToCreate : MonoBehaviour{ [SerializeField] private LayerMask layerToClick; [SerializeField] private Vector3 offset; [SerializeField] Factory[] factories; private Factory factory; private void Update() { GetProductAtClick(); } private void GetProductAtClick() { // check click with raycast if (Input.GetMouseButtonDown(0)) { // choose a random factory factory = factories[Random.Range(0, factories.Length)]; // instantiate product at raycast intersection Ray ray = Camera.main.ScreenPointToRay(Input.mousePosition); RaycastHit hitInfo; if (Physics.Raycast(ray, out hitInfo, Mathf.Infinity, layerToClick) &amp;&amp; factory != null) { factory.GetProduct(hitInfo.point + offset); } } }}","link":"/2024/05/23/Factory-pattern/"},{"title":"Hexo 加入自訂的 HTML頁面","text":"有時候想要記錄一些javascript特效或是小工具時，在Hexo會需要自訂自己的HTML頁面，以下是操作步驟 在Hexo專案下面找到 source 資料夾，新建一個要放自訂HTML的資料夾。我這邊是放html/tools/html_encode 在配置檔案_config.yml中，設定跳過渲染 單個檔案12skip_render: - 'html/***.html' 跳過該資料夾下的所有檔案12skip_render: - 'html/*' 跳過該資料夾下所有檔案以及子資料夾12skip_render: - 'html/**' 之後使用指令清除暫存並開始Server 123hexo cleanhexo ghexo s 訪問網址驗證成果，它會以你資料夾的結構去建立URL，例如我的資料夾結構是html/tools/html_encode，因此在訪問時，就是訪問：http://localhost:4000/html/tools/html_encode/index.html 如果想要在原先的blog中加入這個自訂的HTML頁面，並使用Tag的話，推薦使用 iframe 的方式 12&lt;iframe src='/html/tools/html_encode/index.html' scrolling=&quot;no&quot; frameborder=&quot;0&quot; width='100%' height='800px' style='margin-top:12px'&gt;&lt;/iframe&gt; 結果如下：","link":"/2024/02/08/Hexo-%E5%8A%A0%E5%85%A5%E8%87%AA%E8%A8%82%E7%9A%84-HTML%E9%A0%81%E9%9D%A2/"},{"title":"Input System基本概念","text":"Input System 讓使用者可以透過設備(device)，觸控(touch)或手勢(gestures)控制你的App。若有跨平台開發的需求，或希望提供使用者可自行設定輸入的選項，可考慮使用 Input System。目前Input System是Unity較新的輸入系統，需要透過Project Manager去安裝。 概念 描述 User 就是使用你App的使用者，透過輸入裝置或觸控裝置提供輸入 Input Device 在輸入的環境(context of input)中，指的是實體裝置，例如：鍵盤(keyboard)，遊戲手把(gamepad),滑鼠(mouse)或是觸控螢幕等(touchscreen) Control 指的是輸入裝置的個別部件，各自會將自己的值發送到Unity中。例如：遊戲手把(gamepad)的control包含了多個按鈕(buttons)，搖桿(sticks)，板機(triggers)等；滑鼠的control包含了在底部的兩個X與Y感應器(sensors)與在上面的各種按鈕與滑鼠滾輪等。 Action Action是一個高層次的概念，用來描述在你的App中使用者可能想做的輸入動作，例如：在遊戲中跳躍(Jump)，在畫面上選擇(Select)，也就是說是使用者可以在你App中做出的輸入動作。Action一般會有一個概念名稱，你可以依據你專案使用合適的Action名稱，通常是一個動詞(verbs)，例如Run，Jump，Crouch， Use，Start，Quit Action Map Action Maps讓你可以將Action組織起來，你可以同時啟用或停用在一個Action Map中的action，對組織相關的Action非常有用，例如你可能會想要一個Action Map在裡面Action都與控制玩家相關，而另外一個都與UI互動相關。 Binding 一種將Action與特定控制裝置(specific device control)之間綁定的概念。例如：Move可能會與鍵盤上的WSAD與方向鍵(arrow keys)綁定，或者是遊戲手把(joypad)上的左側搖桿(left stick)綁定，以及VR控制器上的主要2D軸綁定。可以多個綁定，表示你的App可以接受框平台的輸入 Your Action Code 根據Action設定去操作的腳本(script)。在程式碼中，你可以透過Action的參考(reference)來讀取目前action的值或是狀態(此也稱為polling)，也可以設定callback來為這些action添加自己的方法 ActionAsset 是一個儲存了Action Maps與Bindings設定的asset type，你可以在專案中指定一個Action Asset為專案範圍的動作(project-wide actions) 讓你可以透過這樣可以通過使用InputSystem.actions在程式碼中輕鬆參考這些動作 下一篇：安裝Input System Reference: https://docs.unity3d.com/Packages/com.unity.inputsystem@1.8/manual/index.htmlhttps://docs.unity3d.com/Packages/com.unity.inputsystem@1.8/manual/Concepts.html","link":"/2024/04/23/Input-System%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"title":"Hexo添加Sitemap，讓Google能搜尋到自己的Hexo Blog","text":"以下是操作步驟： 安裝Hexo sitemap套件 1$ npm install hexo-generator-sitemap --save 為Hexo加入sitemap設定ˋ找到Hexo專案底下的 _config.yml12sitemap: path: sitemap.xml 測試是否有建立sitemap檔案，在終端機輸入 1$ hexo s 如果成功的話，可以在 /sitemap.xml 找到產生的sitemap 在本機端測試：http://localhost:4000/sitemap.xml 編譯並發布 hexo g -d 提交到Google Search Console 進入 Google Search Console 在網址前置字元那邊輸入Blog的網址，如圖： 在左側找到Sitemap，點擊進入，輸入sitemap.xml，並提交，就完成了。如圖： 如果網站沒有驗證擁有權的話，會需要驗證，可以在Hexo啟用Google analytics，或是使用HTML檔案的方式驗證。 使用HTML檔案的方式驗證的話，要先下載HTML檔案，放到Hexo Blog目錄下，可以參考：Hexo 加入自訂的 HTML頁面","link":"/2024/02/08/Hexo%E6%B7%BB%E5%8A%A0Sitemap/"},{"title":"Flexbox Layout","text":"UI Toolkit使用一個開源的Layout Engine： Yoga，Yoga是一個實作了Flexbox layout的HTML/CSS Layout system。 預設所有Visual Elements都是layout的一部份，在Layout中預設有以下行為 Container會將它的Children做垂直(vertically)分佈 Container矩形(rectangle)的位置包括其children rectangles 在計算尺寸(size calculation)時，若這個visual element有Text的話，會以這個Text的大小來計算 Flexbox基本 Flex Item：在Flexbox中會有一個含有多個元素的Container稱為Flex Container，在這個Flex Container中的element稱為Flex Item Flexbox的layout使用flex-flow directions的方式來做佈局，也就是說裡面的items會根據一個軸來從開頭到結尾做排列，如main axis的話從main-start到main-end排列；或cross axis的話從cross-start到cross-end排列。 Main axis：由main-start到main-end的方向。 預設是由左到右的方向與大部分語言文字方向相同的方向 注意：Main axis不一定是由左到右的方向，它會根據flex-direction改變。 Cross axis：由cross-start到cross-end的方向，也就是換行方向，如果Flex Item單行的數量多到超過Flex Container，需要換行時，預設會換到下一行的方向。 預設是由上到下 Flex direction：設定main axis的方向，有以下方向可以設置 row (預設): 在LRT佈局中是從左到右;在RTL佈局中是從右到左 row-reverse: 與row相反，在LRT佈局中是從右到左;在RTL佈局中是從左到右 column: 方向是從上到下 column-reverse: 與column相反，從下到上 以下是flex-direction為row的範例12345678910111213141516171819&lt;style&gt; .container { display: flex; flex-direction: row; background-color: yellow; } .item{ margin: 10px; width: 60px; height: 60px; background-color: blue; color: white; }&lt;/style&gt;&lt;div class=&quot;container1&quot;&gt; &lt;div class=&quot;item&quot;&gt;item1&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;item2&lt;/div&gt; &lt;div class=&quot;item&quot;&gt;item3&lt;/div&gt;&lt;/div&gt; .container1 { display: flex; flex-direction: row; background-color: yellow; } .item{ margin: 10px; width: 60px; height: 60px; background-color: blue; color: white; } item1 item2 item3 flex-wrap：設定Flex是否換行，預設會讓flex items保持在一行。 nowrap：所有flex items保持在一行 wrap：當flex items多到容不下時，會換到下一行，方向是從上到下 wrap-reverse：wrap的相反，當flex items多到容不下時，會換到上一行，方向是從下到上 以下是flex-wrap的的範例 .container2-1, .container2-2, .container2-3 { display: flex; flex-direction: row; background-color: yellow; } .red { background: red; } .green { background: green; } .blue { background: blue; } .container2-1 { width:200px; flex-wrap: nowrap; } .container2-2 { width:200px; flex-wrap: wrap; } .container2-3 { width:200px; flex-wrap: wrap-reverse; } nowrap 1234567891011121314&lt;style&gt;.container2-1 { display: flex; flex-direction: row; background-color: yellow; width:200px; flex-wrap: nowrap;}&lt;/style&gt;&lt;div class=&quot;container2-1&quot;&gt; &lt;div class=&quot;item red&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;item green&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;item blue&quot;&gt;3&lt;/div&gt;&lt;/div&gt; 1 2 3 wrap 1234567891011121314&lt;style&gt;.container2-2 { display: flex; flex-direction: row; background-color: yellow; width:200px; flex-wrap: wrap;}&lt;/style&gt;&lt;div class=&quot;container2-2&quot;&gt; &lt;div class=&quot;item red&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;item green&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;item blue&quot;&gt;3&lt;/div&gt;&lt;/div&gt; 1 2 3 wrap-reverse 1234567891011121314&lt;style&gt;.container2-3 { display: flex; flex-direction: row; background-color: yellow; width:200px; flex-wrap: wrap-reverse;}&lt;/style&gt;&lt;div class=&quot;container2-3&quot;&gt; &lt;div class=&quot;item red&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;item green&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;item blue&quot;&gt;3&lt;/div&gt;&lt;/div&gt; 1 2 3 justify-content：定義Flex Items在Flex Container在main axis上空間分配的方式 flex-start：Items以flex-direction的開始爲方向排列。 flex-end：Items以flex-direction的尾部為方向排列。 center：Items在中心排列 space-between：Items在main axis上平均排列，但首尾Items貼邊。 space-around：Items在main axis上平均排列，Items之間使用相同的空間 以下是Justify Content的例子 .container3-1, .container3-2, .container3-3, .container3-4, .container3-5 { display: flex; flex-direction: row; background-color: yellow; } .container3-1 { justify-content: flex-start; } .container3-2 { justify-content: flex-end; } .container3-3 { justify-content: center; } .container3-4 { justify-content: space-between; } .container3-5 { justify-content: space-around; } flex-start 12345678910111213&lt;style&gt;.container3-1 { display: flex; flex-direction: row; background-color: yellow; justify-content: flex-start;}&lt;/style&gt;&lt;div class=&quot;container3-1&quot;&gt; &lt;div class=&quot;item red&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;item green&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;item blue&quot;&gt;3&lt;/div&gt;&lt;/div&gt; 1 2 3 flex-end 12345678910111213&lt;style&gt;.container3-2 { display: flex; flex-direction: row; background-color: yellow; justify-content: flex-end;}&lt;/style&gt;&lt;div class=&quot;container3-2&quot;&gt; &lt;div class=&quot;item red&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;item green&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;item blue&quot;&gt;3&lt;/div&gt;&lt;/div&gt; 1 2 3 center 1234567891011.container3-3 { display: flex; flex-direction: row; background-color: yellow; justify-content: center;}&lt;div class=&quot;container3-3&quot;&gt; &lt;div class=&quot;item red&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;item green&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;item blue&quot;&gt;3&lt;/div&gt;&lt;/div&gt; 1 2 3 space-between 1234567891011.container3-4 { display: flex; flex-direction: row; background-color: yellow; justify-content: space-between;}&lt;div class=&quot;container3-4&quot;&gt; &lt;div class=&quot;item red&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;item green&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;item blue&quot;&gt;3&lt;/div&gt;&lt;/div&gt; 1 2 3 space-around 12345678910111213&lt;style&gt;.container3-5 { display: flex; flex-direction: row; background-color: yellow; justify-content: space-around;}&lt;/style&gt;&lt;div class=&quot;container3-5&quot;&gt; &lt;div class=&quot;item red&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;item green&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;item blue&quot;&gt;3&lt;/div&gt;&lt;/div&gt; 1 2 3 align-items：設定Flex Items對cross axis方向的排列方式 flex-start：Items會從cross axis的開始位置對齊 flex-end：Items會從cross axis的尾端位置對齊 stretch：當Items沒有設定高度時，Items會被拉伸填滿Container，(遵守最小寬度(min-width)/最大寬度(max-width)） center：Items會從cross axis的中心位置對齊 以下是align-items的例子 .container4-1, .container4-2, .container4-3, .container4-4 { display: flex; flex-direction: row; background-color: yellow; height: 200px; } .container4-1 { align-items: flex-start; } .container4-2 { align-items: flex-end; } .container4-3 { align-items: stretch; } .container4-4 { align-items: center; } flex-start 1234567891011121314&lt;style&gt;.container4-1 { display: flex; flex-direction: row; background-color: yellow; height: 200px; align-items: flex-start;}&lt;/style&gt;&lt;div class=&quot;container4-1&quot;&gt; &lt;div class=&quot;item red&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;item green&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;item blue&quot;&gt;3&lt;/div&gt;&lt;/div&gt; 1 2 3 flex-end 1234567891011121314&lt;style&gt;.container4-2 { display: flex; flex-direction: row; background-color: yellow; height: 200px; align-items: flex-end;}&lt;/style&gt;&lt;div class=&quot;container4-2&quot;&gt; &lt;div class=&quot;item red&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;item green&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;item blue&quot;&gt;3&lt;/div&gt;&lt;/div&gt; 1 2 3 stretch 1234567891011121314&lt;style&gt;.container4-3 { display: flex; flex-direction: row; background-color: yellow; height: 200px; align-items: stretch;}&lt;/style&gt;&lt;div class=&quot;container4-3&quot;&gt; &lt;div style=&quot;background-color:coral;min-height:30px;width:60px;&quot;&gt;1&lt;/div&gt; &lt;div style=&quot;background-color:lightblue;min-height:50px;width:60px;&quot;&gt;2&lt;/div&gt; &lt;div style=&quot;background-color:lightgreen;min-height:190px;width:60px;&quot;&gt;3&lt;/div&gt;&lt;/div&gt; 1 2 3 center 1234567891011121314&lt;style&gt;.container4-4 { display: flex; flex-direction: row; background-color: yellow; height: 200px; align-items: center;}&lt;div class=&quot;container4-4&quot;&gt; &lt;div class=&quot;item red&quot;&gt;1&lt;/div&gt; &lt;div class=&quot;item green&quot;&gt;2&lt;/div&gt; &lt;div class=&quot;item blue&quot;&gt;3&lt;/div&gt;&lt;/div&gt;&lt;/style&gt; 1 2 3 align-self：與align-items類似，但是只會應用到該Item上 flex-start：Item會從cross axis的開始位置對齊 flex-end：Item會從cross axis的尾端位置對齊 stretch：Item會被拉伸填滿Container，(遵守最小寬度(min-width)/最大寬度(min-width)） center：Item會從cross axis的中心位置對齊 flex-grow：設定item在容器中佔多少空間，或是分到多少剩餘空間。 以下舉例，容器的width為600px，紅色Item1的width為60px，綠色Item2的width為90px，藍色Item3的width為60px： .container5 { display: flex; flex-direction: row; background-color: yellow; width: 600px; color: white; } 沒有設定 flex-grow 1234567891011121314&lt;style&gt;.container5 { display: flex; flex-direction: row; background-color: yellow; width: 600px; color: white;}&lt;/style&gt;&lt;div class=&quot;container5&quot;&gt; &lt;div class=&quot;red&quot; style=&quot;width:60px;&quot;&gt;1(60)&lt;/div&gt; &lt;div class=&quot;green&quot; style=&quot;width:90px;&quot;&gt;2(90)&lt;/div&gt; &lt;div class=&quot;blue&quot; style=&quot;width:60px;&quot;&gt;3(60)&lt;/div&gt;&lt;/div&gt; 1(60) 2(90) 3(60) 紅色Item的flex-grow:1， 剩餘的空間為600-60-90-60=390，這會把剩餘的空間(390)全部分紅色Item 1234567891011121314&lt;style&gt;.container5 { display: flex; flex-direction: row; background-color: yellow; width: 600px; color: white;}&lt;/style&gt;&lt;div class=&quot;container5&quot;&gt; &lt;div class=&quot;red item-a-5-1&quot; style=&quot;width:60px;&quot;&gt;1(60px+390px)&lt;/div&gt; &lt;div class=&quot;green&quot; style=&quot;width:90px;&quot;&gt;2(90px)&lt;/div&gt; &lt;div class=&quot;blue&quot; style=&quot;width:60px;&quot;&gt;3(60px)&lt;/div&gt;&lt;/div&gt; 1(60px+390px) 2(90px) 3(60px) 紅色Item的flex-grow:1， 綠色Item的flex-grow:2， 他們兩個會按比例分配剩餘空間390/3=130，紅色Item分配到130*1，綠色Item分到130*2 1234567891011121314&lt;style&gt;.container5 { display: flex; flex-direction: row; background-color: yellow; width: 600px; color: white;}&lt;/style&gt;&lt;div class=&quot;container5&quot;&gt; &lt;div class=&quot;red item-a-5-1&quot; style=&quot;width:60px;&quot;&gt;1(60+130*1)&lt;/div&gt; &lt;div class=&quot;green item-a-5-2&quot; style=&quot;width:90px;&quot;&gt;2(90+130*2)&lt;/div&gt; &lt;div class=&quot;blue&quot; style=&quot;width:60px;&quot;&gt;3(60)&lt;/div&gt;&lt;/div&gt; 1(60+130*1) 2(90+130*2) 3(60) flex-grow的數值也可以是小數， 紅色Item的flex-grow:0.4， 綠色Item的flex-grow:0.6， 他們兩個按比例分配剩餘空間，紅色Item分配到390*0.4，綠色Item分到390*0.6 1234567891011121314&lt;style&gt;.container5 { display: flex; flex-direction: row; background-color: yellow; width: 600px; color: white;}&lt;/style&gt;&lt;div class=&quot;container5&quot;&gt; &lt;div class=&quot;red&quot; style=&quot;width:60px; flex-grow:0.4;&quot;&gt;1(60+390*0.4)&lt;/div&gt; &lt;div class=&quot;green&quot; style=&quot;width:90px; flex-grow:0.6;&quot;&gt;2(90+390*0.6)&lt;/div&gt; &lt;div class=&quot;blue&quot; style=&quot;width:60px;&quot;&gt;3(60)&lt;/div&gt;&lt;/div&gt; 1(60+390*0.4) 2(90+390*0.6) 3(60) flex-shrink：在容器空間不足時，控制Item如何收縮 此方式計算較複雜，除了flex-shrink設定比例，還需要根據容器中Item超出多少寬度，以及Item它本身的寬度來計算出各個Item收縮的比例。 每個Item收縮的權重為其flex-shrink*寬度。 如果不希望被自動壓縮到，可以設定為0 以下舉例，容器的width為600px，紅色Item1的width為300px，綠色Item2的width為300px，藍色Item3的width為300px，紅色Item的flex-shrink:1，綠色Item的flex-shrink:1，藍色Item的flex-shrink:2 .container6 { display: flex; flex-direction: row; background-color: yellow; width: 600px; color: white; } 計算超出多少寬度：600(容器) - 300(紅色) - 300(綠色) - 300(藍色) = 300 (超出300) 每個Item收縮的權重為其flex-shrink * 寬度：1*300 + 1*300 + 2*300 = 1200 每個Item要收縮的寬度為： 紅色：300(超出的寬度) * 1 (flex-shrink) * 300(Item的寬度) / 1200(權重) = 75 綠色：300(超出的寬度) * 1 (flex-shrink) * 300(Item的寬度) / 1200(權重) = 75 藍色：300(超出的寬度) * 2 (flex-shrink) * 300(Item的寬度) / 1200(權重) = 150 因此三個元素最終的寬度為： 紅色：300 - 75 = 225 綠色：300 - 75 = 225 藍色：300 - 150 = 150 1234567891011121314&lt;style&gt;.container6 { display: flex; flex-direction: row; background-color: yellow; width: 600px; color: white;}&lt;/style&gt;&lt;div class=&quot;container6&quot;&gt; &lt;div class=&quot;red&quot; style=&quot;width:300px; flex-shrink:1;&quot;&gt;225&lt;/div&gt; &lt;div class=&quot;green&quot; style=&quot;width:300px; flex-shrink:1;&quot;&gt;225&lt;/div&gt; &lt;div class=&quot;blue&quot; style=&quot;width:300px; flex-shrink:2;&quot;&gt;150&lt;/div&gt;&lt;/div&gt; 225 225 150 再看另外一個例子：容器的width為600px，紅色Item的width為150px，綠色Item的width為300px，藍色Item的width為300px，紅色Item的flex-shrink:0，綠色Item的flex-shrink:2，藍色Item的flex-shrink:3 計算超出多少寬度：600(容器) - 150(紅色) - 300(綠色) - 300(藍色) = 150 (超出150) 每個Item收縮的權重為其flex-shrink * 寬度：0*150 + 2*300 + 3*300 = 1500 每個Item要收縮的寬度為： 紅色：150(超出的寬度) * 0 (flex-shrink) * 150(Item的寬度) / 1500(權重) = 0 綠色：150(超出的寬度) * 2 (flex-shrink) * 300(Item的寬度) / 1500(權重) = 60 藍色：150(超出的寬度) * 3 (flex-shrink) * 300(Item的寬度) / 1500(權重) = 90 因此三個元素最終的寬度為： 紅色：150 - 0 = 150 綠色：300 - 60 = 240 藍色：300 - 90 = 210 1234567891011121314&lt;style&gt;.container6 { display: flex; flex-direction: row; background-color: yellow; width: 600px; color: white;}&lt;/style&gt;&lt;div class=&quot;container6 width:600px&quot;&gt; &lt;div class=&quot;red&quot; style=&quot;width:150px; flex-shrink:0;&quot;&gt;150&lt;/div&gt; &lt;div class=&quot;green&quot; style=&quot;width:300px; flex-shrink:2;&quot;&gt;240&lt;/div&gt; &lt;div class=&quot;blue&quot; style=&quot;width:300px; flex-shrink:3;&quot;&gt;210&lt;/div&gt;&lt;/div&gt; 150 240 210 flex-shrink也可以是小數：容器的width為600px，紅色Item的width為300px，綠色Item的width為300px，藍色Item的width為300px，紅色Item的flex-shrink:0.1，綠色Item的flex-shrink:0.4，藍色Item的flex-shrink:0.5 計算超出多少寬度：600(容器) - 300(紅色) - 300(綠色) - 300(藍色) = 300 (超出150) 每個Item收縮的權重為其flex-shrink * 寬度：0.1*300 + 0.4*300 + 0.5*300 = 300 每個Item要收縮的寬度為： 紅色：300(超出的寬度) * 0.1 (flex-shrink) * 300(Item的寬度) / 300(權重) = 30 綠色：300(超出的寬度) * 0.4 (flex-shrink) * 300(Item的寬度) / 300(權重) = 120 藍色：300(超出的寬度) * 0.5 (flex-shrink) * 300(Item的寬度) / 300(權重) = 150 因此三個元素最終的寬度為： 紅色：300 - 30 = 270 綠色：300 - 120 = 180 藍色：300 - 150 = 150 1234567891011121314&lt;style&gt;.container6 { display: flex; flex-direction: row; background-color: yellow; width: 600px; color: white;}&lt;/style&gt;&lt;div class=&quot;container6 width:600px&quot;&gt; &lt;div class=&quot;red&quot; style=&quot;width:300px; flex-shrink:0.1;&quot;&gt;270&lt;/div&gt; &lt;div class=&quot;green&quot; style=&quot;width:300px; flex-shrink:0.4;&quot;&gt;180&lt;/div&gt; &lt;div class=&quot;blue&quot; style=&quot;width:300px; flex-shrink:0.5;&quot;&gt;150&lt;/div&gt;&lt;/div&gt; 270 180 150 flex-basis：設定Item佔用空間。如果沒設定或設為auto則Item的值為width(flex-direction:row)或是height(flex-direction:column)的值。 以下是範例： 紅色Item的style=\"width:300px; flex-basis:auto;\"。 綠色Item的style=\"width:300px; flex-basis:100px;\"。 藍色Item的style=\"width:300px;\"。 1234567891011121314&lt;style&gt;.container6 { display: flex; flex-direction: row; background-color: yellow; width: 600px; color: white;}&lt;/style&gt;&lt;div class=&quot;container6 width:600px&quot;&gt; &lt;div class=&quot;red&quot; style=&quot;width:300px; flex-basis:auto;&quot;&gt;300&lt;/div&gt; &lt;div class=&quot;green&quot; style=&quot;width:300px; flex-basis:100px;&quot;&gt;100&lt;/div&gt; &lt;div class=&quot;blue&quot; style=&quot;width:300px;&quot;&gt;300&lt;/div&gt;&lt;/div&gt; 300 100 300 Reference: https://docs.unity3d.com/2020.1/Documentation/Manual/UIE-LayoutEngine.htmlhttps://discussions.unity.com/t/ui-toolkit-introduction-and-flexbox-layout/316856https://css-tricks.com/snippets/css/a-guide-to-flexbox/https://github.com/xieranmaya/blog/issues/9","link":"/2024/04/12/Layout-Engine/"},{"title":"Linux檢查磁碟空間","text":"在Linux中，我們可以使用df指令檢查Linux磁碟空間的使用狀況 句法：df [options] [filesystems] options：可選參數，可以改變df輸出的格式，或是限定查看哪個Filesystem，等。 filesystems：可選的，可以指定特定的文件系統（掛載點（mount point））來檢查它們的使用情況，而不是獲取所有已掛載點的信息。 執行df指令時，將看到：Filesystem、Size（或blocks）、Used、Available、Use%和Mounted On，如下： 12345[root@host /]# dfFilesystem 1K-blocks Used Available Use% Mounted onoverlay 165455088 49616788 115821916 30% /tmpfs 65536 0 65536 0% /devtmpfs 16430216 0 16430216 0% /sys/fs/cgroup FileSystem ：顯示文件系統的名稱。 Size：顯示該文件系統的總容量。 Used：顯示該文件系統使用了多少磁碟空間。 Available：顯示該文件系統還剩下多少空間。 Use%： 顯示已使用空間的百分比。 Mounted On：顯示該文件系統的掛載點。 大部分都會加上 -h 參數，顯示人類比較容易暸解的容量方式，如下 12345[root@host /]# df -hFilesystem Size Used Avail Use% Mounted onoverlay 146G 39G 107G 27% /tmpfs 64M 0 64M 0% /devtmpfs 16G 0 16G 0% /sys/fs/cgroup 指定要顯示的文件系統 /dev 123[root@host /]# df -h /devFilesystem Size Used Avail Use% Mounted ontmpfs 64M 0 64M 0% /dev 以下是常用的參數： df -h ：以人類比較容易暸解的格式顯示結果。 df -m ：以MB為單位顯示結果。 df -k ：以KB為單位顯示結果。","link":"/2024/04/11/Linux%E6%AA%A2%E6%9F%A5%E7%A3%81%E7%A2%9F%E7%A9%BA%E9%96%93/"},{"title":"JSON Pretty","text":"function resizeIframe(iframe) { iframe.height = iframe.contentWindow.document.body.scrollHeight + \"px\"; window.requestAnimationFrame(() => resizeIframe(iframe)); } Reference： https://github.com/pgrabovets/json-view https://stackoverflow.com/questions/4810841/pretty-print-json-using-javascript","link":"/2024/04/17/JSON-pretty/"},{"title":"Liskov substitution principle","text":"里氏替換原則(Liskov substitution principle)：子類(Subclass)必須要可以替代父類(Super class)，即任何父類出現的地方，都可以使用其子類替換，而不影響程式的正確性。 在考慮里氏替換原則時，可以遵循以下幾點： 避免移除特性：如果在父類的行為中，如果子類中沒有這個特性的話，你可能違反了里氏替換原則(If you are removing features when subclassing, you are likely breaking Liskov substitution)。在設計時， 如果子類中出現了NotImplementedException，那你可能違反了里氏替換原則 如果出現只能是空白的方法也可能違反了里氏替換原則 保持抽象簡單：盡量讓抽象保持簡單(Keep abstractions simple)：如果在基類放入越多的邏輯，那你有很大的機率違反了里氏替換原則。基類應只包含子類可以共有的方法。 子類需要有與基類相同的公有成員(A subclass needs to have the same public members as the base class)：這些成員在呼叫時還需要具有相同的行為。 先考慮類的API再建立層次結構：在建立類的層次結構前先考慮它們的API(Consider the class API before establishing class hierarchies)：現實中的分類並不總能完全轉為類的結構，例如汽車(Car)與火車(Train)皆是車輛但它們不能直接繼承同一個父類，最好是將它們分開繼承 優先考慮組合而非繼承(Favor composition over inheritance)：在實作時，先考慮使用介面 (Interface) 或是將行為委託給其他類，而不是直接使用繼承。 例如：假設有一個交通工具 (Vehicle) 的類層次結構，會思考：汽車 (Car) 和卡車 (Truck) 繼承自交通工具 (Vehicle)， 12345678910111213141516171819202122232425public class Vehicle{ public float Speed { get; set; } public Vector3 Direction { get; set; } public virtual void GoForward() { // 移動向前的邏輯 } public virtual void Reverse() { // 倒車的邏輯 } public virtual void TurnRight() { // 右轉的邏輯 } public virtual void TurnLeft() { // 左轉的邏輯 }} 1234567891011public class Navigator{ public void Move(Vehicle vehicle) { vehicle.GoForward(); vehicle.TurnLeft(); vehicle.GoForward(); vehicle.TurnRight(); vehicle.GoForward(); }} 但若是將火車(Train)作為車輛(Vehicle)的子類則會違反里氏替換原則，這是因為火車沒有右轉(TurnRight)與左轉(TurnLeft)的行為，因此火車不能作為車輛(Vehicle)的子類。 為了修正，可以將轉彎(Turn)和移動(Move)動作抽象為介面可轉彎(ITurnable)和可移動(IMovable) 1234567891011public interface ITurnable{ void TurnRight(); void TurnLeft();}public interface IMovable{ void GoForward(); void Reverse();} 並將車輛分為可以在一般道路上行駛的車輛RoadVehicle，它實作可轉彎(ITurnable)和可移動(IMovable) 12345678910111213141516171819202122232425public class RoadVehicle : IMovable, ITurnable{ public float Speed { get; set; } public float TurnSpeed { get; set; } public virtual void GoForward() { // 移動向前的邏輯 } public virtual void Reverse() { // 倒車的邏輯 } public virtual void TurnLeft() { // 左轉的邏輯 } public virtual void TurnRight() { // 右轉的邏輯 }} 與需要在軌道上行駛的車輛RailVehicle，它只實作可移動(IMovable) 1234567891011121314public class RailVehicle : IMovable{ public float Speed { get; set; } public virtual void GoForward() { // 移動向前的邏輯 } public virtual void Reverse() { // 倒車的邏輯 }} 最後，定義汽車和火車的類： 123456789public class Car : RoadVehicle{ // Car特有的實作}public class Train : RailVehicle{ // Train特有的實作} 這樣，Navigator 類可以安全地操作所有可以移動的交通工具，而不需要關心它們是否能轉彎： 1234567891011121314public class Navigator{ public void Move(IMovable movable) { movable.GoForward(); movable.Reverse(); } public void Turn(ITurnable turnable) { turnable.TurnLeft(); turnable.TurnRight(); }}","link":"/2024/05/22/Liskov-substitution-principle/"},{"title":"Interface segregation principle","text":"介面隔離原則(Interface segregation principle)：不應該讓一個類(class)為了實作某個介面(interface)而去讓這個類實作用不到的方法，簡單的說就是要避免一個大型的介面(interface)。最簡單的思考方向是使用單一職責(singleresponsibility principle)去考慮，讓每個介面保持單一並簡單。 假設要製作一個策略遊戲，這個遊戲有多個角色單位，每個單位會有血量，速度，等狀態，可能會想將這些單位的狀態抽象為一個介面，如下： 1234567891011121314151617public interface IUnitStats{ float Health { get; set; } int Defense { get; set; } void Die(); void TakeDamage(); void RestoreHealth(); float MoveSpeed { get; set; } float Acceleration { get; set; } void GoForward(); void Reverse(); void TurnLeft(); void TurnRight(); int Strength { get; set; } int Dexterity { get; set; } int Endurance { get; set; }} 但是在遊戲中，有會有一些不可移動但是可以破壞的物件，這些物件也會需要生命值(Health)，但是不需要移動相關的方法(如GoForward)，因此這個介面太臃腫了。 可以考慮將這些行為切割為較小的介面，每個介面負責專一的職責 1234567891011121314151617181920212223public interface IMovable{ float MoveSpeed { get; set; } float Acceleration { get; set; } void GoForward(); void Reverse(); void TurnLeft(); void TurnRight();}public interface IDamageable{ float Health { get; set; } int Defense { get; set; } void Die(); void TakeDamage(); void RestoreHealth();}public interface IUnitStats{ int Strength { get; set; } int Dexterity { get; set; } int Endurance { get; set; }} 在實作時，敵人單位會移動，有狀態，並且是可損壞的 123456789101112131415161718public class EnemyUnit : MonoBehaviour, IDamageable, IMovable, IUnitStats{ public float Health { get; set; } public int Defense { get; set; } public float MoveSpeed { get; set; } public float Acceleration { get; set; } public int Strength { get; set; } public int Dexterity { get; set; } public int Endurance { get; set; } public void Die() { ... } public void TakeDamage() { ... } public void RestoreHealth() { ... } public void GoForward() { ... } public void Reverse() { ... } public void TurnLeft() { ... } public void TurnRight() { ... }} 箱子只能被損壞 123456789public class Box : MonoBehaviour, IDamageable{ public float Health { get; set; } public int Defense { get; set; } public void Die() { ... } public void TakeDamage() { ... } public void RestoreHealth() { ... }} 這樣，每個類只需要實作其所需的介面，避免了因為實作不必要的方法而增加的複雜性。","link":"/2024/05/22/Interface-segregation-principle/"},{"title":"Mac 截取螢幕圖片","text":"同時按下這三個按鍵：Shift+Command+4，就可以讓你使用滑鼠選擇擷取螢幕某個部分的圖片， Ｗindows中則是按下windows+Shift+s。 同時按下這三個按鍵：Shift+Command+3則是擷取整張桌面的圖。","link":"/2024/02/08/Mac-%E6%88%AA%E5%8F%96%E8%9E%A2%E5%B9%95%E5%9C%96%E7%89%87/"},{"title":"安裝Input System","text":"Input System需要Unity 2019.4或更高版本以及.NET 4 runtime。 安裝Input System package 在編輯器中，找到 Window &gt; Package Manager 打開 Package Manager 更改為Unity Registry，並搜尋 Input System 安裝Input System 選擇是否在後端啟用Input System。Unity預設啟用的是InputManager(UnityEngine.Input)，在安裝Input System時會詢問你是否要啟用Input System，選擇Yes，這會讓編輯器重開。 此外你也可以在Edit &gt; Project Settings &gt; Player 中找到 Active Input Handling來更改 在C# script中，當Input System在後端被啟用時，C# #define 會加入一個ENABLE_INPUT_SYSTEM=1的定義；當原先的Input Manager在後端被啟用時，C# #define會加入一個ENABLE_LEGACY_INPUT_MANAGER=1，如果是同時啟用則ENABLE_INPUT_SYSTEM與ENABLE_LEGACY_INPUT_MANAGER皆會設為1。 上一篇：Input System基本概念 下一篇：將Action設為整個專案可用(Project-Wide Actions) Reference: https://docs.unity3d.com/Packages/com.unity.inputsystem@1.8/manual/ActionsEditor.html","link":"/2024/04/23/Input-System/"},{"title":"Mac 顯示所有隱藏檔案","text":"在 Terminal 中輸入以下指令以顯示所有隱藏文件： 1defaults write com.apple.finder AppleShowAllFiles -bool true 然後，在 Terminal 中輸入以下指令以重新啟動 Finder： 1killall Finder 這樣就可以顯示所有隱藏文件了。","link":"/2024/02/08/Mac-%E9%A1%AF%E7%A4%BA%E6%89%80%E6%9C%89%E9%9A%B1%E8%97%8F%E6%AA%94%E6%A1%88/"},{"title":"Manipulators","text":"Manipulators是處理使用者與UI Element交互的State machine，它被用來儲存，註冊，取消註冊event callbacks。 建立與使用Manipulators你不需要自己撰寫管理callback的class，你只需要要繼承UI Toolkit提供的manipulators class就可以使用它們來管理callback與event，步驟如下： 建立一個class，這個class封裝了針對特定使用者互動所需的事件處理邏輯，並繼承了UI Toolkit提供的manipulators class。 在這個class中，實作方法(method)來回應相關的互動，例如滑鼠點擊或拖曳。這些方法捕獲並處理必要的資訊以執行這個互動行為(behavior)。 當你完成設計這個class之後，你就可以實體化它並將其附加到目標(target) UI Element上。這個附加使這個Manipulator class可以攔截和管理指定的事件，並協調使用者互動，同時與你的UI程式碼保持清晰的分離。 在Visual Element上使用AddManipulator將建立的Manipulator加入到這個Element 在Visual Element上使用RemoveManipulator為這個Element移除指定的的Manipulator 以下是UI Toolkit提供的Manipulator class Manipulator 繼承自 描述 Manipulator 所有manipulators的基類(Base class) KeyboardNavigationManipulator Manipulator 將特定設備輸入事件(device-specific input event)轉換為可以使用鍵盤進行的較高階導航操作(higher-level navigation operations) MouseManipulator Manipulator 處理滑鼠輸入，擁有一個啟用過濾器(ManipulatorActivationFilter)列表 ContextualMenuManipulator MouseManipulator 當使用者按下滑鼠右鍵或是menu鍵時，顯示內容選單(contextual menu) PointerManipulator MouseManipulator 處理指標(pointer)輸入，擁有一個啟用過濾器(ManipulatorActivationFilter)列表 Clickable PointerManipulator 追蹤element上的滑鼠事件並辨認是否發生點擊事件，也就是說在同一個element中是否有發生指標按下並放開 例子以下範例將示範 如何一個繼承PointerManipulator，來處理滑鼠輸入， 並使用activators list屬性來設定可以啟用這個manipulator的條件， 例如：當使用者點擊滑鼠左鍵時，啟用這個manipulator 要做到這個，你只要實體化一個ManipulatorActivationFilter，將其button屬性設為MouseButton.LeftMouse並加入到activators list即可 使用target屬性來存取附加這個manipulator的element， Override RegisterCallbacksOnTarget與UnregisterCallbacksFromTarget方法用以註冊和取消註冊event callbacks。 建立一個可以讓你拖動element的manipulator1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677using UnityEngine;using UnityEngine.UIElements;// 繼承PointerManipulatorpublic class ExampleDragger : PointerManipulator{ private Vector3 m_Start; protected bool m_Active; private int m_PointerId; private Vector2 m_StartSize; public ExampleDragger() { m_PointerId = -1; // 實體化一個`ManipulatorActivationFilter`，將其button屬性設為`MouseButton.LeftMouse`並加入到`activators` list activators.Add(new ManipulatorActivationFilter { button = MouseButton.LeftMouse }); m_Active = false; } // Override RegisterCallbacksOnTarget方法用以註冊event callbacks protected override void RegisterCallbacksOnTarget() { target.RegisterCallback&lt;PointerDownEvent&gt;(OnPointerDown); target.RegisterCallback&lt;PointerMoveEvent&gt;(OnPointerMove); target.RegisterCallback&lt;PointerUpEvent&gt;(OnPointerUp); } // Override UnregisterCallbacksFromTarget方法用以取消註冊event callbacks protected override void UnregisterCallbacksFromTarget() { target.UnregisterCallback&lt;PointerDownEvent&gt;(OnPointerDown); target.UnregisterCallback&lt;PointerMoveEvent&gt;(OnPointerMove); target.UnregisterCallback&lt;PointerUpEvent&gt;(OnPointerUp); } protected void OnPointerDown(PointerDownEvent e) { if (m_Active) { e.StopImmediatePropagation(); return; } if (CanStartManipulation(e)) { m_Start = e.localPosition; m_PointerId = e.pointerId; m_Active = true; target.CapturePointer(m_PointerId); e.StopPropagation(); } } protected void OnPointerMove(PointerMoveEvent e) { if (!m_Active || !target.HasPointerCapture(m_PointerId)) return; Vector2 diff = e.localPosition - m_Start; target.style.top = target.layout.y + diff.y; target.style.left = target.layout.x + diff.x; e.StopPropagation(); } protected void OnPointerUp(PointerUpEvent e) { if (!m_Active || !target.HasPointerCapture(m_PointerId) || !CanStopManipulation(e)) return; m_Active = false; target.ReleaseMouse(); e.StopPropagation(); }} 建立一個可以當拖動時，改變element大小的manipulator12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273using UnityEngine;using UnityEngine.UIElements;public class ExampleResizer : PointerManipulator{ private Vector3 m_Start; protected bool m_Active; private int m_PointerId; private Vector2 m_StartSize; public ExampleResizer() { m_PointerId = -1; activators.Add(new ManipulatorActivationFilter { button = MouseButton.LeftMouse }); m_Active = false; } protected override void RegisterCallbacksOnTarget() { target.RegisterCallback&lt;PointerDownEvent&gt;(OnPointerDown); target.RegisterCallback&lt;PointerMoveEvent&gt;(OnPointerMove); target.RegisterCallback&lt;PointerUpEvent&gt;(OnPointerUp); } protected override void UnregisterCallbacksFromTarget() { target.UnregisterCallback&lt;PointerDownEvent&gt;(OnPointerDown); target.UnregisterCallback&lt;PointerMoveEvent&gt;(OnPointerMove); target.UnregisterCallback&lt;PointerUpEvent&gt;(OnPointerUp); } protected void OnPointerDown(PointerDownEvent e) { if (m_Active) { e.StopImmediatePropagation(); return; } if (CanStartManipulation(e)) { m_Start = e.localPosition; m_StartSize = target.layout.size; m_PointerId = e.pointerId; m_Active = true; target.CapturePointer(m_PointerId); e.StopPropagation(); } } protected void OnPointerMove(PointerMoveEvent e) { if (!m_Active || !target.HasPointerCapture(m_PointerId)) return; Vector2 diff = e.localPosition - m_Start; target.style.height = m_StartSize.y + diff.y; target.style.width = m_StartSize.x + diff.x; e.StopPropagation(); } protected void OnPointerUp(PointerUpEvent e) { if (!m_Active || !target.HasPointerCapture(m_PointerId) || !CanStopManipulation(e)) return; m_Active = false; target.ReleasePointer(m_PointerId); m_PointerId = -1; e.StopPropagation(); }} 加入manipulator1234var myElement = new VisualElement();// 加入manipulator到這個VisualElementmyElement.AddManipulator(new ExampleDragger()); 1234567891011121314var box = new VisualElement(){ style = { left = 100, top = 100, width = 100, height = 100, backgroundColor = Color.red }, pickingMode = PickingMode.Position,};box.AddManipulator(new ExampleResizer()); 移除manipulator12// 為這個VisualElement移除manipulatormyElement.RemoveManipulator&lt;ExampleDragger&gt;();","link":"/2024/04/18/Manipulators/"},{"title":"Object Pool pattern","text":"物件池(Object Pool)：是一種減輕大量建立並銷毀物件時 CPU 負擔的設計模式。使用物件池時，物件會先被建立並放入池中等待，需要時應用程式不會新建物件，而是從物件池中取得並啟用它。當使用完畢後，物件不會被銷毀，而是被放回物件池中。 改進 可以在程式載入時建立物件池，這樣使用者就不會感到卡頓。 考慮將物件池設為static或是singleton的：這樣可以在所有情況下方便呼叫使用。 使用Dictionary來管理多個物件池：如果有多個物件池，可以使用 Key-Value 的資料結構（如 Dictionary）來管理，只需根據對應的 Key 就能方便地取得所需的物件池。 注意釋放物件池中的物件：確保物件在物件池中時不會被釋放，避免執行期間發生錯誤。 設定物件池上限：物件過多會消耗大量記憶體，因此需要為物件池設定一個上限，避免物件池中物件過多。 以下是一個簡單的物件池， 這個物件池使用Stack SetupPool()用來產生一些物件放到物件池中 GetPooledObject()用來啟用物件並取得，當物件不足(stack.Count == 0)時，會再產生一個新物件 ReturnToPool()用來將物件停用，並返回物件到物件池 注意不要直接使用，因為這個例子沒有設定Stack上限，可能會產生過多的物件1234567891011121314151617181920212223242526272829303132333435363738394041424344public class ObjectPool : MonoBehaviour{ [SerializeField] private uint initPoolSize; [SerializeField] private PooledObject objectToPool; // 存儲物件池中的物件 private Stack&lt;PooledObject&gt; stack; private void Start() { SetupPool(); } // 建立物件池（在卡頓不明顯時調用） private void SetupPool() { stack = new Stack&lt;PooledObject&gt;(); PooledObject instance = null; for (int i = 0; i &lt; initPoolSize; i++) { instance = Instantiate(objectToPool); instance.Pool = this; instance.gameObject.SetActive(false); stack.Push(instance); } } // 從物件池中返回第一個可用的物件 public PooledObject GetPooledObject() { // 如果物件不夠，則實例化新的物件 if (stack.Count == 0) { PooledObject newInstance = Instantiate(objectToPool); newInstance.Pool = this; return newInstance; } // 否則，從物件池中取得下一個物件 PooledObject nextInstance = stack.Pop(); nextInstance.gameObject.SetActive(true); return nextInstance; } public void ReturnToPool(PooledObject pooledObject) { stack.Push(pooledObject); pooledObject.gameObject.SetActive(false); } } 建立一個 PooledObject 類別，讓它依賴 ObjectPool，這樣可以在使用完畢後返回物件池： 123456789public class PooledObject : MonoBehaviour{ private ObjectPool pool; public ObjectPool Pool { get =&gt; pool; set =&gt; pool = value; } public void Release() { pool.ReturnToPool(this); }} 在Unity 2021後，有內建 UnityEngine.Pool 物件池，它提供了多種容器的Pool，像是 ObjectPool：是一個Stack DictionaryPool&lt;T0,T1&gt; GenericPool HashSetPool LinkedPool ListPool使用內建 UnityEngine.Pool 物件池有許多好處，包含 可以快速的使用物件池，不需要重複造輪子 有多種容器供你選用 當到達最大物件數量後會摧毀該物件，不建立過多的物件 以下是UnityEngine.Pool的範例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849using UnityEngine.Pool;public class RevisedGun : MonoBehaviour{ // 使用基於 Stack 的 ObjectPool private IObjectPool&lt;RevisedProjectile&gt; objectPool; // 如果嘗試返回已經存在於池中的物件，則拋出異常 [SerializeField] private bool collectionCheck = true; // 控制池的預設容量和最大大小 [SerializeField] private int defaultCapacity = 20; [SerializeField] private int maxSize = 100; private void Awake() { objectPool = new ObjectPool&lt;RevisedProjectile&gt;(CreateProjectile, OnGetFromPool, OnReleaseToPool, OnDestroyPooledObject, collectionCheck, defaultCapacity, maxSize); } // 在new ObjectPool建構子中使用，主要是先建立物件以填充物件池 private RevisedProjectile CreateProjectile() { RevisedProjectile projectileInstance = Instantiate(projectilePrefab); projectileInstance.ObjectPool = objectPool; return projectileInstance; } // 在new ObjectPool建構子中使用，告訴物件池在將物件返回時要做什麼動作 private void OnReleaseToPool(RevisedProjectile pooledObject) { pooledObject.gameObject.SetActive(false); } // 在new ObjectPool建構子中使用，告訴物件池在物件池中取出物件時要做什麼初始化動作 private void OnGetFromPool(RevisedProjectile pooledObject) { pooledObject.gameObject.SetActive(true); } // 在new ObjectPool建構子中使用，告訴物件池在超過最大物件數量時如何銷毀物件 private void OnDestroyPooledObject(RevisedProjectile pooledObject) { Destroy(pooledObject.gameObject); } private void FixedUpdate() { // 省略其他代碼 }} 與上面簡單的ObjectPool相同，讓RevisedProjectile依賴 IObjectPool&lt;RevisedProjectile&gt;，在使用完畢後呼叫objectPool.Release(this)返回物件池： 12345678910111213141516171819202122232425262728public class RevisedProjectile : MonoBehaviour{ // 延遲後停用 [SerializeField] private float timeoutDelay = 3f; private IObjectPool&lt;RevisedProjectile&gt; objectPool; // 公共屬性，用於給 projectile 一個 ObjectPool 的引用 public IObjectPool&lt;RevisedProjectile&gt; ObjectPool { set =&gt; objectPool = value; } public void Deactivate() { StartCoroutine(DeactivateRoutine(timeoutDelay)); } private IEnumerator DeactivateRoutine(float delay) { yield return new WaitForSeconds(delay); // 重置移動中的 Rigidbody Rigidbody rBody = GetComponent&lt;Rigidbody&gt;(); rBody.velocity = Vector3.zero; rBody.angularVelocity = Vector3.zero; // 將 projectile 返回到物件池 objectPool.Release(this); }} Reference: https://github.com/Unity-Technologies/game-programming-patterns-demo/tree/main/Assets/7%20Object%20Pool","link":"/2024/05/24/Object-Pool/"},{"title":"Physics Material實體材質","text":"實體材質，決定你的物體摩擦力與彈性，讓你的物件可以滑動或是反彈 在專案的畫面中使用滑鼠右鍵，找到Create -&gt; 如果是2D，選擇 -&gt; 2D -&gt; Physics Material 2D 如果是3D，選擇 -&gt; Material 參數簡介 Dynamic Friction：已在移動時使用的摩擦力，通常為0到1之間的值 值為0時，就像冰一樣，會滑動 值為1時，將使物件迅速靜止，除非使用很大的力或重力推動該物件 Static Friction：當物件靜止在表面上時的摩擦力，通常為0到1之間 值為0時，就像冰一樣，會滑動 值為1時，將使物件很難推動 Bounciness：表面的彈性， 值為0時，不會反彈 值為1時，在反彈時不會產生任何能量損失，可以一直反彈 Friction Combine：兩個碰撞物件的摩擦力的組合方式 Average：對兩個摩擦值求平均值 Minimum：使用兩個值中最小的值 Maximum：使用兩個值中最大的值 Multiply：兩個摩擦值相乘 Bounce Combine：兩個碰撞物件的彈性組合方式，其模式與Friction Combine相同","link":"/2024/04/03/Material%E7%A2%B0%E6%92%9E%E6%9D%90%E8%B3%AA/"},{"title":"Project-Wide Actions","text":"Input System的project-wide actions功能讓你可以設定一個能夠在整個專案中使用的Action Asset，當Action Asset設為project-wide actions之後，那這個action就是個preloaded asset，也就是說當你的App啟動後就會載入，並且一直保持可用直到App關閉為止。 建立Project-Wide Actions Asset 找到 Edit &gt; Project Settings &gt; Input System Package 並按下 Create a new project-wide Action Asset 在專案中會建立一個名為InputSystem_Actions的Action Asset。 這個InputSystem_Actions中已經有一些預設的Action，像是Move，Jump等，符合大部分遊戲，並預設綁定大部分裝置如鍵盤，滑鼠，遊戲搖桿，觸控螢幕，XR等 在程式碼中使用InputSystem.actions去找到Action1InputSystem.actions.FindAction(&quot;Move&quot;); 上一篇：安裝Input System 下一篇：使用Action Editor編輯Action Reference: https://docs.unity3d.com/Packages/com.unity.inputsystem@1.8/manual/ProjectWideActions.html","link":"/2024/04/25/Project-Wide-Actions/"},{"title":"Observer pattern","text":"在遊戲中，會發生很多事，例如擊敗一個敵人，玩家升級等，如果直接將這些行為直接在各個物件中執行，會增加很多依賴，當程式碼成長到一定程度時，會變得很難維護。 觀察者模式(Observer pattern)通常會用來解決此問題。它使用一種one-to-many依賴(dependency)，讓你的物件之間的溝通可以保持在一種低耦合(loosely coupled)的關係，當一個物件的狀態改變時，會自動通知所有想要接收此訊息的物件。例如廣播系統，廣播會向外發送音樂給收聽者，廣播不需要知道誰在收聽，它只要使用固定的頻道發送音樂即可，而收聽者只需要將頻道調整到該廣播系統的頻道即可收到音樂。 發送消息的物件稱為subject 其他接收此消息的物件稱為observers 優點： 發送消息的物件(subject)與接收此消息的物件(observers)解耦 發送消息的物件不需要知道關於接收此消息的物件的資訊，它只需要負責將消息發送出去； 接收此消息的物件會有一個發送消息物件的依賴，但是接收此消息的物件之間互相不知道彼此 將observer需要對訊息做出反應的邏輯放到對應的observer中，讓他們各自維護。變得較容易測試與除錯 非常適合使用者介面(User Interface)，MVP與MVC patterns就是使用觀察者模式(Observer pattern) 缺點： 增加程式複雜度， 如果要刪除Subject的話會比較麻煩 Observer仍然會對Subject有依賴， 可以使用一個static EventManager除去 會消耗一些效能 在C#中已經有實作Observer pattern =&gt; Event publisher(即subject)：有一個或多個event，在執行時，會將訊息發送給註冊這些event的物件 observers：這些物件會有一些event handler的方法，當publisher發送訊息時，便會執行對應的event handler方法 以下是一個最簡單的例子Subject有一個 event ThingHappened，它暴露給其他物件讓它們可以註冊 123456789public class Subject{ public event Action ThingHappened; public void DoThing() { ThingHappened?.Invoke(); }} Observer有一個Subject依賴，用來註冊；並且有一個OnEventHandler，當Subject發送訊息時，便會執行這個方法 12345678910111213141516public class Observer{ private Subject subjectToObserve; public Observer(Subject subject) { subjectToObserve = subject; subjectToObserve.ThingHappened += OnEventHandle; } private void OnEventHandler() { // any logic that responds to event goes here Debug.Log(&quot;Observer responds&quot;); }} Reference: https://unity.com/how-to/create-modular-and-maintainable-code-observer-pattern","link":"/2024/05/22/Observer-pattern/"},{"title":"Open-closed principle","text":"開閉原則(Open-closed principle)：開閉原則指的是類(Class)要可以對外擴展(open for extension)，但是對內部修改封閉(closed for modification)。簡單的說就是可以為你的程式添加新的行為，但是不去修改現有程式碼。 一個經典的例子是計算體積，我們要建立一個 AreaCalculator 類，用來計算物體的體積， 下面是一個不遵守開閉原則的例子。 定義了一個AreaCalculator類，它含有GetRectangleArea與GetCircleArea方法，分別用來計算四邊形與圓形的體積 定義了一個Rectangle類，用來存放四邊形的寬和高 定義了一個Circle類，用來存放圓形半徑12345678910111213141516171819202122public class AreaCalculator{ public float GetRectangleArea(Rectangle rectangle) { return rectangle.width * rectangle.height; } public float GetCircleArea(Circle circle) { return circle.radius * circle.radius * Mathf.PI; }}public class Rectangle{ public float width; public float height;}public class Circle{ public float radius;} 這個AreaCalculator類是可以運作的如預期，但是如果添加更多計算體積的方法（例如三角形或五邊形），就會一直變更這個AreaCalculator類，這違反了開閉原則。 建立一個Shape基類， 1234public abstract class Shape{ public abstract float CalculateArea();} 所有物體皆繼承這個Shape基類 12345678910111213141516171819public class Rectangle : Shape{ public float width; public float height; public override float CalculateArea() { return width * height; }}public class Circle : Shape{ public float radius; public override float CalculateArea() { return radius * radius * Mathf.PI; }} AreaCalculator類更改為依賴Shape 1234567public class AreaCalculator{ public float GetArea(Shape shape) { return shape.CalculateArea(); }} 如此每當添加新物體時，也不用更改AreaCalculator類，只需要新增一個繼承Shape的類即可","link":"/2024/05/22/Open-closed-principle/"},{"title":"Single-responsibility principle","text":"單一職責(Single-responsibility principle)：一個類(class)應該只因為它負責的那件事而被更改。 注意：在單一職責中，要取得平衡，不要過度的拆分，例如拆分到一個類中只有一個方法。 拆分時可以考慮以下因素： 可讀性(Readability)：簡短的類通常比較容易閱讀和理解。雖然“簡短”沒有明確的定義，但通常開發者認為200~300行的類是比較合適的。 擴展性(Extensibility)：類是否容易擴展，修改或替換這些類時不應該無意破壞其他部分。 可重用性(Reusability)：是否可以更方便地重新使用這些類 以下是一個將聲音，輸入，移動皆包含在一起的Player類，隨著專案的發展，這個類會越來愈難維護，例如更改聲音會動到這個類，更改移動輸入會動到這個類… 123456789101112131415161718192021222324public class UnrefactoredPlayer : MonoBehaviour{ [SerializeField] private string inputAxisName; [SerializeField] private float positionMultiplier; private float yPosition; private AudioSource bounceSfx; private void Start() { bounceSfx = GetComponent&lt;AudioSource&gt;(); } private void Update() { float delta = Input.GetAxis(inputAxisName) * Time.deltaTime; yPosition = Mathf.Clamp(yPosition + delta, -1, 1); transform.position = new Vector3(transform.position.x, yPosition * positionMultiplier, transform.position.z); } private void OnTriggerEnter(Collider other) { bounceSfx.Play(); }} 應考慮將這些行為拆分到各自的類，如 PlayerAudio、PlayerInput、PlayerMovement 等。Player 類仍然依賴這些行為，但這些行為已經被拆分到各自的類中。 1234567891011121314151617181920212223242526272829[RequireComponent(typeof(PlayerAudio), typeof(PlayerInput), typeof(PlayerMovement))]public class Player : MonoBehaviour{ private PlayerAudio playerAudio; private PlayerInput playerInput; private PlayerMovement playerMovement; private void Start() { playerAudio = GetComponent&lt;PlayerAudio&gt;(); playerInput = GetComponent&lt;PlayerInput&gt;(); playerMovement = GetComponent&lt;PlayerMovement&gt;(); }}public class PlayerAudio : MonoBehaviour{ // PlayerAudio specific implementation}public class PlayerInput : MonoBehaviour{ // PlayerInput specific implementation}public class PlayerMovement : MonoBehaviour{ // PlayerMovement specific implementation}","link":"/2024/05/22/Single-responsibility-principle/"},{"title":"SOLID principles","text":"SOLID principles是程式設計師必須了解的五個原則 單一職責原則(Single responsibility)：確保類只負責一件事。 開閉原則(Open-closed)：在不更改現有程式碼的情況下，可以擴展一個類的功能。 里氏替換原則(Liskov substitution)：子類可以替代基類，而不影響程式的正確性。 介面隔離原則(Interface segregation)：讓介面(interface)盡可能簡單，確保實作類只需要實作其所需的介面方法。 依賴倒置原則(Dependency inversion)：高層模組不應依賴於低層模組，兩者都應依賴於抽象。具體實現應依賴於抽象，而不是抽象依賴於具體實現。 這些原則可以讓你的程式設計更具彈性和可維護性，但在不確定是否要使用它們時，請記住KISS（Keep It Simple, Stupid）原則，不要強迫將其應用於程式碼中。","link":"/2024/05/22/SOLID-principles/"},{"title":"Singleton pattern","text":"單例模式(Singleton pattern)：確保應用程式中只有一個實例，並且提供簡單的全局訪問方式。 然而，單例模式在一些設計模式中被認為弊大於利，被列為反模式(anti-pattern)，這是因為單例模式太容易使用了導致開發人員很容易設計出不必要的全域狀態或是全域依賴。 優點 使用簡單，單例是全域可存取的，很容易的就可以取道該單例並在程式中使用。 由於單例是全域可存取因此你不需要去想使否需要暫存它。 缺點 全局存取：單例是全域可存取的，違反了 SOLD原則。 測試困難：單例模式使得測試必須互相獨立變得困難，因為單例可以直接改變狀態。 強依賴性：單例造成的依賴性太強，如果你想更改某個單例，就需要更改所有有使用到它的地方。 以下是一個簡單的單例模式 public static Instance用來保存Sence中的單例實體 在Awake()中檢查是否已有這個實例，如果沒有則將其設為實例；如果有則表示有重複設定，需要將它銷毀，以確保在這個場景中只有一個實例。 這個SimpleSingleton有一些缺陷 當載入新Scene時會銷毀這個GameObject(可以使用 DontDestroyOnLoad 告訴Unity不要摧毀它) 在使用時需要將它附加到Scene結構中123456789101112131415161718using UnityEngine;public class SimpleSingleton : MonoBehaviour{ public static SimpleSingleton Instance; private void Awake() { if (Instance == null) { Instance = this; } else { Destroy(gameObject); } }} 也可以使用延遲初始化(Lazy initialization)的方式，來建立單例，下面例子中 使用 DontDestroyOnLoad(gameObject) 告訴 Unity 不要銷毀它，因此即使切換場景也不會清除這個單例。 不需要手動附加到Scene結構中，因為使用了 SetupInstance()，如果目前還沒有建立這個單例，它會自動建立一個 GameObject 並附加到它身上。1234567891011121314151617181920212223242526272829303132333435363738394041public class Singleton : MonoBehaviour{ private static Singleton instance; public static Singleton Instance { get { if (instance == null) { SetupInstance(); } return instance; } } private void Awake() { if (instance == null) { instance = this; DontDestroyOnLoad(this.gameObject); } else { Destroy(gameObject); } } private static void SetupInstance() { instance = FindObjectOfType&lt;Singleton&gt;(); if (instance == null) { GameObject gameObj = new GameObject(); gameObj.name = &quot;Singleton&quot;; instance = gameObj.AddComponent&lt;Singleton&gt;(); DontDestroyOnLoad(gameObj); } }} 更進一步地將它一般化。在上面的單例模式中，如果需要多個不同的單例，例如 AudioManager 和 GameManager，那麼會複製很多相同的程式碼來建立單例。因此，可以將這個步驟一般化，如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public abstract class MonoSingleton&lt;T&gt; : MonoBehaviour where T : MonoSingleton&lt;T&gt;{ private static T instance; public static T Instance { get { if (instance == null) { instance = FindFirstObjectByType&lt;T&gt;(); if (instance == null) { SetupInstance(); } } return instance; } } public virtual void Awake() { RemoveDuplicates(); } private static void SetupInstance() { instance = FindFirstObjectByType&lt;T&gt;(); if (instance == null) { GameObject gameObj = new(); gameObj.name = typeof(T).Name; instance = gameObj.AddComponent&lt;T&gt;(); DontDestroyOnLoad(gameObj); } } private void RemoveDuplicates() { if (instance == null) { instance = this as T; DontDestroyOnLoad(gameObject); } else { Destroy(gameObject); } }} 之後你在使用時，只需要繼承他即可 1234public class GameManager: Singleton&lt;GameManager&gt;{ // ...} Reference: https://github.com/Unity-Technologies/game-programming-patterns-demo/tree/main/Assets/8%20Singleton","link":"/2024/05/24/Singleton-pattern/"},{"title":"UI Builder - 2 （開始使用UI Builder）","text":"使用UI Builder建立UI的流程一般會是 建立一個新UI Document (UXML) 為你的UI結構加入element 在 Inspector 中調整element的attributes與style 如果有多個element使用相同的style，可以建立USS style sheets與selectors(類似網頁的css) 測試UI是否符合你的需求，並將inline style放到USS中 儲存UI Document (UXML) 以下範例將 建立一個root element作為background，這個root element會含有兩個containers。 一個container用來放角色名稱的list， 另外一個用來放角色的詳細資訊。 在這個角色的詳細資訊container中會加入background與foreground frames。 以及兩個label，用來顯示角色名稱 建立Root Element 首先建立一個Unity專案 開啟UI Builder， Window &gt; UI Toolkit &gt; UI Builder 在UI Builder的Viewpoint中左上角找到File &gt; New建立一個新的UXML document 選擇Save，儲存為MainView.uxml 在左下角Library中，找到VisualElement，將它拖入Viewport中（雙擊VisualElement也可以） 在右側``Inspector`中，找到Inlined Styled，可以在此處修改element的風格 找到Flex，將Grow設為1，這會把flex-grow的值設為1，讓它填滿整個螢幕 接著找到Align，將Align Items與Justify Content都設為Center 把Background的Color設為#732526，並將透明度設為255 建立Parent Container 在左下角Library中，將VisualElement拖入前面建立的rootVisualElement中。 將這個新建VisualElement它的Flex中的Direction設為row，並把它Size中的Height設為350 pixels 建立角色名稱List Container 在左下角Library中，找到ListView將它拖入前面建立的Parent ContainerVisualElement中 修改這個ListView的name，改為CharacterList 將這個ListView它Size中的Width設為230 pixels，並找到Margin &amp; Padding &gt; Margin &gt; Right把Right設為6 設定它的Background &gt; Color為#6E3925，並設定透明度為255 設定它的Border &gt; Color為#311A11，並設定透明度為255 設定它的Border &gt; Width設為4pixels，Radius設為15pixels。 此時你的UI看起來會長這樣 建立角色詳細訊息 Container 在Parent Container中再加入一個VisualElement， 將它 Align &gt; Align Items設為flex-end，並且把Align &gt; Justify Content設為space-between 將它Flex &gt; Basis &gt; Shrink設為0，並且把Flex &gt; Basis &gt; Grow也設為0 在這個VisualElement中加入一個VisualElement 為這個VisualElement設定Size &gt; Width為276pixels；Align &gt; Align Items為center；Align &gt; Justify Content為center；最後設定Margin &amp; Padding &gt; Padding為8 pixels。 為這個VisualElement設定Background &gt; Color為#AA5939，並設定透明度為255 為這個VisualElement設定Border &gt; Color為#311A11，透明度設為255 為這個VisualElement設定Border &gt; Width設為4pixels，Radius設為15pixels。 此時你的UI看起來會長這樣 建立角色詳細訊息框背景 在角色詳細訊息 Container中加入一個VisualElement 將它的Size的Width與Height設為120pixels 將它的Margin &amp; Padding &gt; Padding設為4pixels 將它的Background &gt; Color設為#FF8554，透明度設為255 將它的Border &gt; Color為#311A11，透明度設為255 將它的Border &gt; Width設為4pixels，Radius設為15pixels此時你的UI看起來會長這樣 建立USS來管理Style在建立UI時，可以發現Border的Style都是一樣的，因此我們可以把它們拿出來放到一個USS中方便管理 在StyleSheet選擇 + &gt; Create New USS 儲存為MainView.uss 點擊新建的MainView.uss，並在右側的Inspertor中Selector輸入框中輸入.border，之後在點擊Create New USS Selector 接著你可以在左側的StyleSheet中看到剛剛建立的.borderclass 點擊.borderclass後，在右側的Inspertor，將Border &gt; Color設為#311A11 將它的Border &gt; Width設為2pixels，Radius設為15pixels 將這個.borderclass拖動到角色詳細訊息 Container與角色詳細訊息框的VisualElement 點選角色詳細訊息 Container與角色詳細訊息框的VisualElement，在右側的Inspertor中找到Border，並對Border按下滑鼠右鍵，會跳出一個選單，選擇Unset將Border的inline style清除。 建立角色詳細訊息框前景 在角色詳細訊息框背景的VisualElement加入一個VisualElement並將它命名為CharacterPortrait 設定它的Flex &gt; Grow為1，這樣它裡面的圖片就可以充滿整個可用空間。 設定它的Background &gt; Scale Mode為scale-to-fit，這樣它的圖片就可以充滿element size，並且保持適當的長寬比(aspect ratio) 建立角色詳細訊息Labels 在角色詳細訊息框背景的VisualElement加入兩個Labels，並分別命名為CharacterName與CharacterClass 選擇#CharacterName，將它的Text &gt; Font Style改為B；Text &gt; Size改為18 pixels 在Attributes &gt; Text中可以更改顯示的字串 最後你的UI看起來會長這樣Reference: https://docs.unity3d.com/Manual/UIB-getting-started.html 上一篇：UI Builder - 1 （UI Builder介面簡介） 下一篇：UI Builder - 3 （使用C# Script操控UI)","link":"/2024/04/09/UI-Builder-2-%EF%BC%88%E9%96%8B%E5%A7%8B%E4%BD%BF%E7%94%A8UI-Builder%EF%BC%89/"},{"title":"UI Builder - 3 （使用C# Script操控UI）","text":"在UI-Builder-2-（開始使用UI-Builder）中以建立一個空白的UI，接下來我們要開始為這個UI添加內容。 建立空白UI 首先需要為這些Element命名，為了方便起見，先將這段UXML複製1234567891011121314151617&lt;ui:UXML xmlns:ui=&quot;UnityEngine.UIElements&quot; xmlns:uie=&quot;UnityEditor.UIElements&quot; editor-extension-mode=&quot;False&quot;&gt;&lt;Style src=&quot;MainView.uss&quot; /&gt;&lt;ui:VisualElement name=&quot;background&quot;&gt; &lt;ui:VisualElement name=&quot;main-container&quot;&gt; &lt;ui:ListView focusable=&quot;true&quot; name=&quot;character-list&quot; /&gt; &lt;ui:VisualElement name=&quot;right-container&quot;&gt; &lt;ui:VisualElement name=&quot;details-container&quot;&gt; &lt;ui:VisualElement name=&quot;details&quot;&gt; &lt;ui:VisualElement name=&quot;character-portrait&quot; /&gt; &lt;/ui:VisualElement&gt; &lt;ui:Label text=&quot;Label&quot; name=&quot;character-name&quot; /&gt; &lt;ui:Label text=&quot;Label&quot; display-tooltip-when-elided=&quot;true&quot; name=&quot;character-class&quot; /&gt; &lt;/ui:VisualElement&gt; &lt;/ui:VisualElement&gt; &lt;/ui:VisualElement&gt;&lt;/ui:VisualElement&gt;&lt;/ui:UXML&gt; 接著在專案中，找到MainView.uxml，滑鼠左鍵點選旁邊的小箭頭，把它點開，會出現會出現inlineStyle 對著inlineStyle滑鼠左鍵點兩下，就會用IDE開啟MainView.uxml 接著把上面的UXML內容複製進去，存檔。 再開啟MainView.uss，把下面這一段內容複製進去，存檔12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#background { flex-grow: 1; align-items: center; justify-content: center; background-color: rgb(115, 37, 38);}#main-container { flex-direction: row; height: 350px;}#character-list { width: 230px; border-color: rgb(49, 26, 17); border-width: 4px; background-color: rgb(110, 57, 37); border-radius: 15px; margin-right: 6px;}#character-name { -unity-font-style: bold; font-size: 18px;}#CharacterClass { margin-top: 2px; margin-bottom: 8px; padding-top: 0; padding-bottom: 0;}#right-container{ justify-content: space-between; align-items: flex-end;}#details-container{ align-items: center; background-color: rgb(170, 89, 57); border-width: 4px; border-color: rgb(49, 26, 17); border-radius: 15px; width: 252px; justify-content: center; padding: 8px; height: 163px;}#details{ border-color: rgb(49, 26, 17); border-width: 2px; height: 120px; width: 120px; border-radius: 13px; padding: 4px; background-color: rgb(255, 133, 84);}#character-portrait{ flex-grow: 1; -unity-background-scale-mode: scale-to-fit;} 接著再打開UI Builder，就可以看到一個空白的UI了。 建立一個List Enrty 在專案畫面，建立一個ListEntry.uxml，Create &gt; UI Toolkit &gt; UI Document 將以下內容貼上123456&lt;ui:UXML xmlns:ui=&quot;UnityEngine.UIElements&quot; xmlns:uie=&quot;UnityEditor.UIElements&quot; editor-extension-mode=&quot;False&quot;&gt;&lt;Style src=&quot;ListEntry.uss&quot; /&gt;&lt;ui:VisualElement name=&quot;list-entry&quot;&gt; &lt;ui:Label text=&quot;Label&quot; display-tooltip-when-elided=&quot;true&quot; name=&quot;character-name&quot; /&gt;&lt;/ui:VisualElement&gt;&lt;/ui:UXML&gt; 其中&lt;Style src=&quot;ListEntry.uss&quot; /&gt;會引用等一下建立的ListEntry.uss 使用類似的方式，Create &gt; UI Toolkit &gt; Style Sheet，建立一個ListEntry.uss，並將以下內容貼上12345678910111213141516#list-entry { height: 41px; align-items: flex-start; justify-content: center; padding-left: 10px; background-color: rgb(170, 89, 57); border-color: rgb(49, 26, 17); border-width: 2px; border-radius: 15px;}#character-name { -unity-font-style: bold; font-size: 18px; color: rgb(49, 26, 17);} 可以使用UI Builder打開這個ListEntry.uxml來觀看UI的樣貌 建立 C# Script與其互動 在Asset資料夾下面，建立一個Scripts資料夾 建立一個CharacterData.cs 將以下內容複製到CharacterData.cs 1234567891011121314using UnityEngine;public enum ECharacterClass{ Knight, Ranger, Wizard}[CreateAssetMenu] // 這個Attribute會在Create選單中加入這個CharacterDatapublic class CharacterData : ScriptableObject{ public string CharacterName; public ECharacterClass Class; public Sprite PortraitImage;} 在Asset資料夾下面，建立一個Resources資料夾 在Resources資料夾下面，建立一個Characters資料夾 Characters資料夾中，選擇Create &gt; Character Data建立一個ScriptableObject 將UI放到Sence中 在Scene選擇GameObject &gt; UI Toolkit &gt; UI Document，建立一個UI Document GameObject 在Hierarchy視窗中選擇UIDocument Game Object，將MainView.uxml拖放到右側的Source Asset中 建立Controllers在專案中建立兩個C# controller，與一個MainView CharacterListEntryController：負責更新ListEntry.uxml的Label CharacterListController：負責處理MainView.uxml MainView繼承MonoBehaviour，主要用來與UIDocument GameObject連結，取得UIDocument Game Object後，把它放入CharacterListController 123456789101112131415161718using UnityEngine.UIElements;public class CharacterListEntryController{ Label NameLabel; // 這個function用來設定VisualElement，讓這個controller可以更改label public void SetVisualElement(VisualElement visualElement) { NameLabel = visualElement.Q&lt;Label&gt;(&quot;character-name&quot;); } // 使用CharacterData設定Label的Text public void SetCharacterData(CharacterData characterData) { NameLabel.text = characterData.CharacterName; }} 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100using System.Collections.Generic;using UnityEngine;using UnityEngine.UIElements;public class CharacterListController{ // UXML template for list entries VisualTreeAsset ListEntryTemplate; // UI element references ListView CharacterList; Label CharClassLabel; Label CharNameLabel; VisualElement CharPortrait; public void InitializeCharacterList(VisualElement root, VisualTreeAsset listElementTemplate) { EnumerateAllCharacters(); // Store a reference to the template for the list entries ListEntryTemplate = listElementTemplate; // Store a reference to the character list element CharacterList = root.Q&lt;ListView&gt;(&quot;character-list&quot;); // Store references to the selected character info elements CharClassLabel = root.Q&lt;Label&gt;(&quot;character-class&quot;); CharNameLabel = root.Q&lt;Label&gt;(&quot;character-name&quot;); CharPortrait = root.Q&lt;VisualElement&gt;(&quot;character-portrait&quot;); FillCharacterList(); // Register to get a callback when an item is selected CharacterList.onSelectionChange += OnCharacterSelected; } List&lt;CharacterData&gt; AllCharacters; void EnumerateAllCharacters() { AllCharacters = new List&lt;CharacterData&gt;(); AllCharacters.AddRange(Resources.LoadAll&lt;CharacterData&gt;(&quot;Characters&quot;)); } void FillCharacterList() { // Set up a make item function for a list entry CharacterList.makeItem = () =&gt; { // Instantiate the UXML template for the entry var newListEntry = ListEntryTemplate.Instantiate(); // Instantiate a controller for the data var newListEntryLogic = new CharacterListEntryController(); // Assign the controller script to the visual element newListEntry.userData = newListEntryLogic; // Initialize the controller script newListEntryLogic.SetVisualElement(newListEntry); // Return the root of the instantiated visual tree return newListEntry; }; // Set up bind function for a specific list entry CharacterList.bindItem = (item, index) =&gt; { (item.userData as CharacterListEntryController).SetCharacterData(AllCharacters[index]); }; // Set a fixed item height CharacterList.fixedItemHeight = 45; // Set the actual item's source list/array CharacterList.itemsSource = AllCharacters; } void OnCharacterSelected(IEnumerable&lt;object&gt; selectedItems) { // Get the currently selected item directly from the ListView var selectedCharacter = CharacterList.selectedItem as CharacterData; // Handle none-selection (Escape to deselect everything) if (selectedCharacter == null) { // Clear CharClassLabel.text = &quot;&quot;; CharNameLabel.text = &quot;&quot;; CharPortrait.style.backgroundImage = null; return; } // Fill in character details CharClassLabel.text = selectedCharacter.Class.ToString(); CharNameLabel.text = selectedCharacter.CharacterName; CharPortrait.style.backgroundImage = new StyleBackground(selectedCharacter.PortraitImage); }} 123456789101112131415161718using UnityEngine;using UnityEngine.UIElements;public class MainView : MonoBehaviour{ [SerializeField] VisualTreeAsset ListEntryTemplate; void OnEnable() { // The UXML is already instantiated by the UIDocument component var uiDocument = GetComponent&lt;UIDocument&gt;(); // Initialize the character list controller var characterListController = new CharacterListController(); characterListController.InitializeCharacterList(uiDocument.rootVisualElement, ListEntryTemplate); }} 將MainView拖入UIDocument GameObject。 將ListEntry.uxml拖入ListEntryTemplate Reference：https://docs.unity3d.com/Manual/UIE-HowTo-CreateRuntimeUI.html 上一篇：UI-Builder-2-（開始使用UI-Builder）","link":"/2024/04/11/UI-Builder-3-%EF%BC%88%E8%88%87Element%E4%BA%92%E5%8B%95%EF%BC%89/"},{"title":"UI Builder - 1 （UI Builder介面簡介）","text":"UI Builder，是一個可視化的UI編輯工具，讓你可以在使用UI Toolkit時可以編輯UI assets，如UI Documents(.uxml)與StyleSheets(.uss)，此外還可以安裝以下的package增加額外的功能 com.unity.vectorgraphics：讓你可以將VectorImage指定為元素(element)的background style com.unity.2d.sprite：讓你可以將 2D Sprite asset(或sub-asset)指定為元素的background style。安裝了此套件後，還可以直接從Inspector窗格中打開2D Sprite編輯器。 選擇 Window -&gt; UI Toolkit -&gt; UI Builder便可開啟UI Builder畫面 StyleSheets：讓你編輯目前UI Document(UXML)的StyleSheets(USS) Hierarchy：顯示目前UI Document的element結構樹 在這個Hierarchy中顯示的是element的name attribute，如果這個element沒有name則顯示它的C# type Library：顯示目前可以使用的elements，其中Standard為Unity內建的elements；Project則為專案中自訂的element (.uxml assets以及繼承VisualElement並有在UxmlFactory設定可以被UXML實體化的C# element )。 Viewport：會顯示UI Document (UXML) 的畫面，並會儲存目前UI Document (UXML)的平移(pan)和縮放(zoom)狀態 使用滑鼠中鍵(Middle-click)，或是使用Ctrl/Cmd + Alt/Option + 滑鼠左鍵可以拖動Viewport。 使用滑鼠滾輪可以縮放Viewport。 UXML Preview與USS Preview：此處可以預覽UI Builder產生的UXML與USS Inspector：與Unity原有的Inspector類似，根據選擇的element顯示對應的設定內容 下一篇：UI-Builder-2-（開始使用UI-Builder）","link":"/2024/04/08/UI-Builder/"},{"title":"Visual Tree","text":"UI Toolkit是用於開發使用者介面 (UI) 功能、資源和工具的集合，UI Toolkit啟發於 web technologies。它是一個retained-mode UI system，支援stylesheets，dynamic與contextual event handling Visual element：在UI Toolkit中，組成UI的最基礎block為Visual element，在C#程式碼中，它繼承VisualElement，你可以設定它的風格(style)，定義它的行為，讓它作為UI的一部份顯示在screen上面。 Visual Tree：由Visual element組成的有序且具父子關係(parent-child relationships)的樹狀結構(hierarchy tree)。 一個簡單的 Visual Tree 所有在Visual Tree中的node都繼承VisualElement，VisualElement的子類定義了各種UI的功能如Button，Text input fields等，稱為Controls，Unity提供很多內建的Controls。 Panels：是一個visual tree的parent object，它擁有rootVisualElement，但是它不是visual element，panel也負責處理focus control與為visual tree分派事件(event dispatching)。 Draw order：visual tree是使用depth-first search，因此他的順序會是 最上面的visual element 這個visual element的第一個child element 這個child element的後代 座標(Coordinate)與位置(Position)系統：在UI Toolkit中，它使用style properties中的layout parameters去計算每個element的座標與位置，基於Flexbox。 相對(Relative)位置：相對於元素計算位置的座標，布局系統(layout system)計算元素的位置，然後將座標添加為偏移量。父元素可以影響子元素的大小和位置，因為布局引擎在計算元素位置時將它們考慮在內。子元素只能影響父元素的大小。 絕對(Absolute)位置：相對於父元素的座標，這繞過自動布局計算，直接設置元素的位置。在相同父元素下的同級元素(Sibling elements)對該元素的位置沒有影響。同樣地，該元素不影響相同父元素下其他同級元素的位置和大小。 Reference: https://docs.unity3d.com/Packages/com.unity.ui.builder@1.0/manual/uib-interface-overview.htmlhttps://docs.unity3d.com/Manual/UIElements.html","link":"/2024/04/06/UI-Toolkit/"},{"title":"Unity Rigidbody","text":"Rigidbody（剛體）component：可將Rigidbody應用到你的遊戲物件(GameObject)上，讓這個GameObject可以被物理的方式控制，也將是說讓這個GameObject可以被physics forces(物理力，如推力，阻力等) 與 torque(扭力)作用。 另外在2D遊戲中，則是使用Rigidbody2D component它只會做用在2D環境，也就是說只能在XY plane上作用。 參數簡介 Body Type(Rigidbody2D) Dynamic（動態，預設值） 運動時受力影響，並且接受完全的物理模擬，包括重力、碰撞、施加力等，最耗效能。 Kinematic（運動學） 不受力影響但可移動，其運動行爲是被我們開發者完全限定的，可以碰撞，沒有設定質量(Mass)的參數 只會與Dynamic2D碰撞 Static（靜態） 不受力影響也不會動，會與動態類型剛體碰撞，最不消耗效能。 Mass：質量，預設為千克，質量越大慣性越大，質量越大越不容易被別的物體推動 Drag：空氣阻力，根據移動物件時影響物件的空氣阻力大小，0表示沒有空氣阻力 Angular Drag：根據樞紐旋轉物件時影響物件的空氣阻力大小，0表示沒有空氣阻力 Use Gravity：是否受重力影響 Is Kinematic：如果啟用此選項，則物件不會被物理引擎驅動，只能透過Transform對其進行操作， 對於移動平台，或者如果要動畫化附加了HingeJoint的剛體，此屬性非常有用 Interpolate：插值運算，讓剛體物體移動更平滑 None：不使用 Interpolate：根據前一幀的變換來平滑變換 Extrapolate：根據下一幀估計的變換來平滑變換 Collision Detection：碰撞檢測，用於防止快速移動的物體其他物體而不檢測碰撞 Discrete：預設值，離散檢測， 最不耗效能的檢測， 對場景中所有其他碰撞體使用離散碰撞檢測， 用於一般碰撞。 可能會出現當物體移動太快造成偵測不到與其他物體碰撞。 Continuous：連續檢測， 對動態碰撞體(具有剛體)，使用離散檢測 對靜態碰撞體(沒有剛體)，使用連續檢測 對於所有其他剛體碰撞使用離散檢測 較消耗物理效能 Continuous Dynamic：連續動態檢測 對動態碰撞體(具有剛體)與靜態碰撞體(沒有剛體)都使用連續碰撞檢測 對於所有其他剛體碰撞使用離散檢測 用於快速移動的物體 Continuous Speculative：連續推測檢測 對剛體和碰撞體使用推測性連續碰撞檢測， 一般比Continuous Dynamic的成本低 Constraints：約束，對剛體運動的限制 Freeze Position：有選擇地停止剛體沿世界X, Y, 和 Z軸的移動 Freeze Rotation：有選擇地停止剛體圍繞局部X, Y, 和 Z軸的轉動 Collision Detection的效能消耗為Continuous Dynamic &gt; Continuous Speculative &gt; Continuous &gt; Discrete 無剛體 Discrete Continuous Continuous Dynamic Continuous Speculative 無剛體 不檢測碰撞 Discrete Continuous Continuous Continuous Speculative Discrete Discrete Discrete Discrete Discrete Continuous Speculative Continuous Continuous Discrete Discrete Continuous Continuous Speculative Continuous Dynamic Continuous Discrete Continuous Continuous Continuous Speculative Continuous Speculative Continuous Speculative Continuous Speculative Continuous Speculative Continuous Speculative Continuous Speculative","link":"/2024/04/03/Unity-Rigidbody/"},{"title":"Unity使用NuGet","text":"在Visual Studio下有方便的NuGet package manager 管理套件，所以可以很方便的安裝和管理NuGet套件，但是對Unity C# 專案來說，就不能直接使用NuGet package manager來管理套件。 幸好有第三方管理套件，NuGetForUnity 可以使用。 以下說明它的使用方式 進入Releas找到的它的unitypackage檔案下載（目前是NuGetForUnity.4.0.2.unitypackage這個版本）。 將下載好的unitypackage檔案拖入你的專案，按下import，便會開始匯入(import) NuGetForUnity到你的專案中。 之後你就可以在上方選單找到NuGet了","link":"/2024/04/01/Unity%E4%BD%BF%E7%94%A8NuGet/"},{"title":"Unity Style Sheet (USS)","text":"USS檔案以.uss為副檔名，它是一個文字檔，可以定義UI共用的風格(style)，讓App更容易管理整體的風格。一個USS會包含以下 Style rules：一個style rule會有一個selector與一個declaration block。 Selector定義了哪些visual element會應用這個style rule Declaration block：使用角括弧(curly braces)，在其中可以定義多個style。 每個sytle都會有一個property與value，並在結尾要加上一個分號(semi-colon) 句法如下 1234selector { property1: value; property2: value;} 例子 123Button { width: 200px;} Type selector：會挑選符合對應C#或是visual element type的elements1234Button { border-radius: 8px; width: 100px; } 注意以下是不合法的Type selector 123UnityEngine.UIElements.Button { ... } Class selector：會挑選有指定該USS class的elements。在class的命名中： 在名字中不要有英文句號 假設一個class名為yellow.button，在建立USS規則(USS rule)的話會這樣使用.yellow.button{...}，這樣會被當成yellow和button兩個class 不可以以數字作為開頭 class名稱是大小寫敏感的(case-sensitive) 在USS中，class selector要以英文句號 . (period)開頭 在UXML中，只需設定class名稱，如：class=&quot;yellow&quot;即可 下面定義了一個 yellow class selector rule，注意它前面有一個英文句號(period)， 123.yellow { background-color: yellow;} 在UXML中要使用的話，使用class=&quot;名稱&quot;例如：&lt;Button name=&quot;OK&quot; class=&quot;yellow&quot; text=&quot;OK&quot; /&gt; 一個簡單的例子如下： 12345678&lt;UXML xmlns=&quot;UnityEngine.UIElements&quot;&gt; &lt;VisualElement name=&quot;container1&quot;&gt; &lt;VisualElement name=&quot;container2&quot; class=&quot;yellow&quot;&gt; &lt;Button name=&quot;OK&quot; class=&quot;yellow&quot; text=&quot;OK&quot; /&gt; &lt;Button name=&quot;Cancel&quot; text=&quot;Cancel&quot; /&gt; &lt;/VisualElement&gt; &lt;/VisualElement&gt;&lt;/UXML&gt; Name selector：會挑選name相符合的elements。(有點類似CSS中的ID selector)。name的使用： 為element設定name的方式有兩種 在C# script中使用 VisualElement.name 在UXML中使用 name 屬性，例如：&lt;VisualElement name=&quot;my-nameName&quot;&gt;. 為了避免意外，name必須唯一。 在USS中，name selector需要以 #(number sign) 開頭 例如#ElementName { ... } 在UXML中，只需設定class名稱，如：name=&quot;my-nameName&quot;即可 `&lt;Button name=&quot;#OK&quot; /&gt;`這個是不合法的。 下面定義一個name為Cancel的name selector rule 12345#Cancel { border-width: 2px; border-color: DarkRed; background-color: pink;} 在UXML中使用的話，使用name=&quot;名稱&quot;例如：&lt;Button name=&quot;Cancel&quot; text=&quot;Cancel&quot; /&gt; 12345678&lt;UXML xmlns=&quot;UnityEngine.UIElements&quot;&gt; &lt;VisualElement name=&quot;container1&quot;&gt; &lt;VisualElement name=&quot;container2&quot; class=&quot;yellow&quot;&gt; &lt;Button name=&quot;OK&quot; class=&quot;yellow&quot; text=&quot;OK&quot; /&gt; &lt;Button name=&quot;Cancel&quot; text=&quot;Cancel&quot; /&gt; &lt;/VisualElement&gt; &lt;/VisualElement&gt;&lt;/UXML&gt; Universal selector：也稱為wildcard selector，它會匹配所有的element。以 * (asterisk)為Universal selector 下面定義一個Universal selector 123* { background-color: yellow;} 以下的UXML的所有element都會應用這個background-color: yellowstyle 12345678&lt;UXML xmlns=&quot;UnityEngine.UIElements&quot;&gt; &lt;VisualElement name=&quot;container1&quot;&gt; &lt;VisualElement name=&quot;container2&quot; class=&quot;yellow&quot;&gt; &lt;Button name=&quot;OK&quot; class=&quot;yellow&quot; text=&quot;OK&quot; /&gt; &lt;Button name=&quot;Cancel&quot; text=&quot;Cancel&quot; /&gt; &lt;/VisualElement&gt; &lt;/VisualElement&gt;&lt;/UXML&gt; Descendant selector：會在visual tree中選出匹配的後代elements。注意，使用這個selector比較消耗效能語法如下： 1selector1 selector2 {...} 例子：這個例子會選擇#container1之下含有yellow class的所有child elements。 1234#container1 .yellow { background-color: yellow;} 在UXML中的設定如下，#container1有一個child element，#container2有class=&quot;yellow&quot;， 123456789&lt;UXML xmlns=&quot;UnityEngine.UIElements&quot;&gt; &lt;VisualElement name=&quot;container1&quot;&gt; &lt;VisualElement name=&quot;container2&quot; class=&quot;yellow&quot;&gt; &lt;Button name=&quot;OK&quot; class=&quot;yellow&quot; text=&quot;OK&quot; /&gt; &lt;Button name=&quot;Cancel&quot; text=&quot;Cancel&quot; /&gt; &lt;/VisualElement&gt; &lt;/VisualElement&gt;&lt;/UXML&gt; 結果如下圖，#container2與#OK以及#Cancel的背景色都被改變了，但#container1的背景沒有被改變 Child selector：會在visual tree中選出匹配的child elements。語法如下： 1selector1 &gt; selector2 {...} 例子：這個例子會選擇#container1的child中含有yellow class的所有child elements。 1234#container1 &gt; .yellow { background-color: yellow;} 在UXML中的設定如下， 12345678&lt;UXML xmlns=&quot;UnityEngine.UIElements&quot;&gt; &lt;VisualElement name=&quot;container1&quot;&gt; &lt;VisualElement name=&quot;container2&quot; class=&quot;yellow&quot;&gt; &lt;Button name=&quot;OK&quot; class=&quot;yellow&quot; text=&quot;OK&quot; /&gt; &lt;Button name=&quot;Cancel&quot; text=&quot;Cancel&quot; /&gt; &lt;/VisualElement&gt; &lt;/VisualElement&gt;&lt;/UXML&gt; 這個的child selector style rule 只會匹配到#container2， 這是因為#container2為#container1的child element，並且含有yellow class。 而#OK與#Cancel不匹配的原因是因為它們是屬於#container2的child而不直接的屬於#container1的child，所以匹配不到。 你也可以把wildcard selector使用在這些複雜的selector，例如以下這個selector rule，它會找出yellow class下的所有Button element 1.yellow &gt; * &gt; Button{..} Multiple selector：Multiple selector是組合多個simple selector它會選出符合simple selector的elements。以下是語法 1selector1selector2 {...} 如果Multiple selector區分不出selector的話，會把它們當作一個，例如ListView與Button這兩個type selector，若想使用Multiple selector會變成下面這樣 1ListViewButton{...} USS parser無法辨識出它是兩個selector，會把它當作一個ListViewButton。因為Class與Name selector有一個前綴詞(分別是.與#)，所以可以辨認出來，而Type selector沒有，所以在使用Multiple selector若是想要用Type selector的話，Type selector必須放到第一個。 1ListView.yellow#vertical-list{...} 在下面這個例子中，最後會選出來的是&lt;Button name=&quot;OK&quot; class=&quot;yellow&quot; text=&quot;OK&quot; /&gt; 123Button.yellow { background-color: yellow;} 12345678&lt;UXML xmlns=&quot;UnityEngine.UIElements&quot;&gt; &lt;VisualElement name=&quot;container1&quot;&gt; &lt;VisualElement name=&quot;container2&quot; class=&quot;yellow&quot;&gt; &lt;Button name=&quot;OK&quot; class=&quot;yellow&quot; text=&quot;OK&quot; /&gt; &lt;Button name=&quot;Cancel&quot; text=&quot;Cancel&quot; /&gt; &lt;/VisualElement&gt; &lt;/VisualElement&gt;&lt;/UXML&gt; Reference: https://docs.unity3d.com/Manual/UIE-about-uss.html","link":"/2024/04/09/Unity-Style-Sheet-USS/"},{"title":"Unity Extensible Markup Language(UXML)","text":"UXML啟發於HTML，XAML與XML，它定義並保存了UI的結構，可以使用Inline Style或是透過Unity Style Sheet來更改UI的風格(Style)。 UXML使用了類似樹狀的結構來保存UI，它存在父子關係(parent-child relationships)以及一個根元素(root element) 以下是UXML的範例 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;UXML ...&gt; &lt;Box&gt; &lt;Toggle name=&quot;boots&quot; label=&quot;Boots&quot; value=&quot;false&quot; /&gt; &lt;Toggle name=&quot;helmet&quot; label=&quot;Helmet&quot; value=&quot;false&quot; /&gt; &lt;Toggle name=&quot;cloak&quot; label=&quot;Cloak of invisibility&quot; value=&quot;false&quot;/&gt; &lt;/Box&gt; &lt;Box&gt; &lt;Button name=&quot;cancel&quot; text=&quot;Cancel&quot; /&gt; &lt;Button name=&quot;ok&quot; text=&quot;OK&quot; /&gt; &lt;/Box&gt;&lt;/UXML&gt; UXML declaration：在上面範例的第一行，是UXML declaration，它是可選的， 如果你使用UXML declaration的話，必須把它放在第一行， 使用UXML declaration的話，必須為它設定version； encoding則是可選的，但是如果使用encoding的話，必須指定它的編碼。 Document root：&lt;UXML&gt;為文件的根element，在此定義namespace與schema definition files的位置。 Namespace：在UI Toolkit中每個element的Namespace不是在UnityEngine.UIElements就是在UnityEditor.UIElements。 UnityEngine.UIElements：此命名空間下的elements會作為Unity runtime時的一部分 UnityEditor.UIElements：此命名空間下的elements可在Unity Editor使用 在使用時，你可以指定element的namespace，例如：&lt;UnityEngine.UIElements:Button /&gt; 或是在UXML declaration中指定它的prefix，如xmlns:engine=&quot;UnityEngine.UIElements&quot;，在使用時會變為&lt;engine:Button /&gt; 注意：不要把自訂的control class放到UnityEngine.UIElements與UnityEditor.UIElements不然UI Builder會把你自訂的control隱藏。 Schema definition：它指定了每個UXML element可以包含哪些attributes和子element。 所有Element都會繼承VisualElement，這個VisualElement提供了以下attributes name: 用來辨認這個element，它的名稱應該要唯一。 picking-mode: 設定為Position表示可以回應滑鼠事件，設定為Ignore表示忽略滑鼠事件 focus-index: (OBSOLETE過時了) Use tabIndex and focusable. tabindex: 一個整數，定義這個element的tabbing position focusable: 一個Boolean，表示這個element是focusable. class: 類似HTML的class，你可以為特定的element加上class，讓它們應用到指定的style；你也可以把它當做篩選element的工具，透過UQuery來找到特定class的elements。 tooltip: 當滑鼠指到該element時，會顯示提示字串 view-data-key : 一個字串，作為element序列化(serialization)時使用的Key 使用Unity建立UXML： 選擇Asset -&gt; Create -&gt; UI Toolkit -&gt; UI Document 預設它會幫你建立一個noNamespaceSchemaLocation 123&lt;ui:UXML xmlns:ui=&quot;UnityEngine.UIElements&quot; xmlns:uie=&quot;UnityEditor.UIElements&quot; xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; engine=&quot;UnityEngine.UIElements&quot; editor=&quot;UnityEditor.UIElements&quot; noNamespaceSchemaLocation=&quot;../../UIElementsSchema/UIElements.xsd&quot; editor-extension-mode=&quot;False&quot;&gt;&lt;/ui:UXML&gt; Reference: https://docs.unity3d.com/Manual/UIE-WritingUXMLTemplate.html","link":"/2024/04/09/UXML/"},{"title":"Unity架構分層","text":"將專案分為四層 表現層：為ViewController 或是 MonoBehaviour腳本，在這一層主要與顯示相關 表現邏輯：指的是當Model資料變更之後，View顯示更新之後的資料，即Model -&gt; View；可以使用呼叫方法，委託，事件三種方式完成。 交互邏輯：為接收使用者輸入之後改變Model資料，即View -&gt; Model；可以使用Command pattern減輕Controller的負擔，注意：command是沒有狀態的，他類似一個方法，呼叫之後就不用了 Model層：管理資料，提供資料的增刪改查 Utility層：工具層，提供一些共用的工具，如資料儲存、網路連接、藍芽、序列化與反序列化等 System層：系統層，提供API且有狀態的物件，例如藍芽服務，計時器服務，網路服務等 這四層的交互 表現層改變Model層與System層的狀態會使用Command， System層與Model層通知表現層使用事件或是委託， 表現層查詢狀態時可以直接獲取System層和Model層 。 一般，表現層不會訪問到Utility層，Utility層也不會通知表現層","link":"/2024/02/05/Unity%E5%88%86%E5%B1%A4/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2024/02/05/hello-world/"},{"title":"事務( Transaction )","text":"事務(Transaction)事務或是交易(Transaction)是指資料庫中邏輯上的一系列操作(operation)，這組操作要就全部成功，要就全部不成功。 start transaction;或是begin;：為開啟事務，在這條SQL語句之後的SQL都將處於同一個事務中，這些SQL語句不會立刻執行。 commit;：為提交事務，一旦提交，事務中所有的SQL才會執行。 rollback;：回滾事務，回復在此事務內所有的動作。 資料庫如果沒有自己去控制事務，預設是一條SQL就處在自己單獨的事務中。 事務的特性(ACID)原子性(Atomicity)：一個事務中的所有操作，要麼全部完成，要麼全部不完成，不會結束在中間某個環節。事務在執行過程中發生錯誤，會被回滾（Rollback）到事務開始前的狀態，就像這個事務從來沒有執行過一樣。 例如：銀行帳戶存款和取款操作。每次存款或取款操作都應該是原子性的，即要麼全部成功，要麼全部失敗。 用戶A要取款300元。在這個操作中，銀行應該首先檢查用戶A的帳戶餘額是否足夠，然後從帳戶餘額上減去取款金額。這個操作是原子性的，要麼成功從用戶A的帳戶中扣除300元，要麼失敗，不會出現只減少部分金額的情況。 一致性(Consistency)：在事務開始之前和事務結束以後，資料庫的完整性沒有被破壞。這表示寫入的資料必須完全符合所有的預設規則，這包含資料的精確度、串聯性以及後續資料庫可以自發性地完成預定的工作。簡單來說就是在事務前後，資料必須保持一致，但在過程中不一定會保持一致性。 例如：A將1000元轉帳至B的帳戶，此事務包含兩個步驟， 銀行從A的帳戶中扣除1000元。 銀行將1000元存入B的帳戶中。 在事務前的A與B的帳戶金額總和一定會和事務後的A與B帳戶內的金額總相同 =&gt; 這就是事務前後，資料必須保持一致 但是在各操作時，資料不一致，例如銀行從A的帳戶中扣除1000元這一個操作做完之後，銀行資料庫的金額會處於不一致狀態(少了1000元)，等到第二操作(銀行將1000元存入B的帳戶)之後資料庫才會保持一致性的狀態。 隔離性(Isolation)：資料庫允許多個併發事務同時對其資料進行讀寫和修改的能力，隔離性可以防止多個事務併發執行時由於交叉執行而導致資料數據的不一致。事務隔離分為不同級別，包括 讀未提交（Read uncommitted）：允許讀取其他事務尚未提交的資料。因此，可能發生髒讀、不可重複讀和幻讀。 讀提交（Read committed）：只能讀取已經提交的資料。因此，可能發生不可重複讀和幻讀，但不會發生髒讀。 可重複讀（Repeatable read）：在同一個事務中多次讀取相同資料時，保證資料的一致性。因此，可能發生幻讀，但不會發生髒讀和不可重複讀。 串行化（Serializable）：最高的隔離級別，確保並發事務之間的串行執行，避免任何並發問題。因此，不會發生髒讀、不可重複讀和幻讀。 持久性(Durability)：事務處理結束後，對資料的修改就是永久的，即便系統故障也不會丟失。 事務隔離性導致的問題：髒讀：髒讀發生在一個事務允許讀取另一個事務修改但未提交的資料時。 例如，當一個事務A正在讀取資料並且對資料進行了修改，但這個修改還沒有被提交到資料庫中。此時，另一個事務B可能會讀取到這個未提交的修改，這就是髒讀的情況。 不可重複讀：在一次事務中，當一行資料獲取兩遍得到不同的結果表示發生了「不可重複讀」。例如，在一個事務A中多次讀取同一筆資料，在事務A還未結束時，另一個事務B也訪問了這個資料，並且修改這個資料並且commit，那麼事務A在多次讀取這筆資料時可能會讀到不同的資料。 不可重複讀的重點是修改：同樣的條件，你讀取過的資料，再次讀取出來發現值不一樣了 例如： 在交易A中，使用SELECT語句讀取賬戶餘額為1000元，然後執行其他操作。 在交易B中，進行了一次轉賬操作，將賬戶餘額從1000元減少到900元。 再次在交易A中，使用相同的SELECT語句讀取賬戶餘額，發現餘額為900元，與之前的餘額不一致。 這是因為在兩次讀取之間，資料表中的資料已經被修改 幻讀：在事務執行過程中，當兩個完全相同的查詢語句執行得到不同的結果集。這種現象稱為「幻讀（phantom read）」。 幻讀的重點在於新增或者刪除：同樣的條件，第1次和第2次讀出來的記錄數目不一幻讀。 例如：目前工資為1000的員工有10人。 使用 SELECT count(*) FROM employee WHERE salary=1000; SQL，讀取所有工資為1000的員工。 事務A，讀取所有工資為1000的員工，共讀取到了10條記錄。 這時事務B向employee表插入了一條員工記錄，工資也為1000 事務A，使用相同的SQL再次讀取所有工資為1000的員工，此時共讀取到了11條記錄。 隔離級別 髒讀 不可重複讀 幻影讀 未提交讀 可能發生 可能發生 可能發生 提交讀 - 可能發生 可能發生 可重複讀 - - 可能發生 可序列化 - - - 一般情況下，大多數資料庫系統的預設隔離級別是可重複讀（Repeatable Read）。這意味著在同一個事務中，多次讀取相同的資料時，保證資料的一致性，並且防止不可重複讀取的情況發生。","link":"/2024/04/19/%E4%BA%8B%E5%8B%99-Transaction/"},{"title":"JavaScript 事件傳遞(Event Bubbling)","text":"HTML結構HTML DOM elements是嵌套(nested)的結構，如下： 12345&lt;div onclick=&quot;alert('點擊最外層');&quot;&gt;First // 最外層 &lt;div onclick=&quot;alert('點擊第二層');&quot;&gt;Second &lt;div onclick=&quot;alert('點擊最內層');&quot;&gt;Third&lt;/div&gt; // 最內層 &lt;/div&gt;&lt;/div&gt; Event Bubbling使用JavaScript可以對HTML DOM element註冊(register)一些不同的event handlers，Event bubbling是HTML DOM API中事件傳播(event propagation)的一種方式。 Bubbling事件傳播的方式為：從事件發生的地方開始一層一層的向最外層傳遞 下面的例子（可以用滑鼠點點看）： 最外層 第二層 最內層 1234567891011&lt;div onclick=&quot;alert('點擊最外層');&quot; style=&quot;background: red; border: 3px dotted black; text-align: center; width: 400px;&quot;&gt; 最外層 &lt;br /&gt; &lt;div onclick=&quot;alert('點擊第二層');&quot; style=&quot;background: green; border: 4px dotted black; text-align: center; width:300px;&quot;&gt; 第二層 &lt;br /&gt; &lt;div onclick=&quot;alert('點擊最內層');&quot; style=&quot;background: blue; border: 5px dotted black; text-align: center; width: 250px;&quot;&gt; &lt;font color=&quot;white&quot;&gt;最內層&lt;/font&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 當你點下（也就是觸發onclick事件）最裡面藍色的那一層的時候，會彈出點擊最內層的字串，然後再彈出點擊第二層的字串，最後再彈出點擊最外層的字串。這就是Bubbling事件傳播 停止Event Bubbling有時候會想要停止bubbling傳遞事件，可以透過以下的方式來停止， event.stopPropagation(); event.cancelBubble = true; // IE&lt;9 例如下面的例子（可以用滑鼠點點看）： function disableBubbling(){ alert('點擊了' + event.srcElement.className); event.stopPropagation(); } 最外層 第二層 最內層 123456789101112131415&lt;script&gt;function disableBubbling(){ alert('點擊了' + event.srcElement.className); event.stopPropagation();}&lt;/script&gt;&lt;div class=&quot;最外層&quot; onclick=&quot;disableBubbling();&quot; style=&quot;background: red; border: 3px dotted black; text-align: center; width: 400px;&quot;&gt; 最外層&lt;br /&gt; &lt;div class=&quot;第二層&quot; onclick=&quot;disableBubbling();&quot; style=&quot;background: green; border: 4px dotted black; text-align: center; width: 300px;&quot;&gt; 第二層&lt;br /&gt; &lt;div class=&quot;最內層&quot; onclick=&quot;disableBubbling();&quot; style=&quot;background: blue; border: 5px dotted black; text-align: center; width: 250px;&quot;&gt; &lt;font color=&quot;white&quot;&gt;最內層&lt;/font&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;","link":"/2024/04/18/%E4%BB%80%E9%BA%BC%E6%98%AFbubbling%EF%BC%9F/"},{"title":"使用Hexo Admin","text":"透過 hexo-admin 這套插件，就能透過GUI介面進行後台管理，如新增或編輯markdown文件，簡化了發布文章的流程。 安裝套件 使用終端機，並移動到Hexo專案位置下，之後執行以下指令1$ npm install --save hexo-admin 安裝完成之後，啟動本地端Server就可以進入後台管理，如下 bash $ hexo server -d 進入 http://localhost:4000/admin 可進入後台管理 注意： Hexo Admin已經不維護了","link":"/2024/02/05/%E4%BD%BF%E7%94%A8Hexo-Admin/"},{"title":"使用LiteDB","text":"LiteDB是一個簡單且快速的NoSQL Database，它特色有 輕巧，&lt; 450kb並且完全由.NET C#受控程式碼(managed code)編寫 可以使用NuGet套件管理器安裝 跨平台 單一存放檔案 支援LINQ query 以下是簡易的使用方式 使用NuGet管理套件搜尋LiteDB並安裝 接下來便可以使用LiteDatabase建立或是開啟database 123456string dbPath = @&quot;./MyData.db&quot;;// Open database (or create if doesn't exist)using (var db = new LiteDatabase(dbPath)){ ...} 建立一個POCO class 123456789public class Customer{ public int Id { get; set; } public string Name { get; set; } public int Age { get; set; } public string[] Phones { get; set; } public bool IsActive { get; set; }} 使用 db.GetCollection&lt;Customer&gt;(&quot;customers&quot;) 去取得customer collection collection的Insert方法插入資料 以下是完整的例子（來自LiteDB） 1234567891011121314151617181920212223242526272829303132string dbPath = @&quot;./MyData.db&quot;;// Open database (or create if doesn't exist)using (var db = new LiteDatabase(dbPath)){ // Get customer collection var col = db.GetCollection&lt;Customer&gt;(&quot;customers&quot;); // Create your new customer instance var customer = new Customer { Name = &quot;John Doe&quot;, Phones = new string[] { &quot;8000-0000&quot;, &quot;9000-0000&quot; }, Age = 39, IsActive = true }; // Create unique index in Name field col.EnsureIndex(x =&gt; x.Name, true); // Insert new customer document (Id will be auto-incremented) col.Insert(customer); // Update a document inside a collection customer.Name = &quot;123John Doe212&quot;; col.Update(customer); // Use LINQ to query documents (with no index) var results = col.Find(x =&gt; x.Age &gt; 20);} 以下是方便你操作DB的GUI介面工具 OneBella：跨平台的GUI工具，支援修改和查詢，需要LiteDB 5+ 使用方式非常簡單，進入OneBella的 Release選擇下載對應平台的zip檔案即可 LiteDB.Studio 一樣去Release下載最新版本即可，目前似乎只有Windows版本。","link":"/2024/04/01/%E4%BD%BF%E7%94%A8LiteDB/"},{"title":"使用Action","text":"有兩種方式回應Action Polling(輪詢)：Polling方法是不斷的檢查你感興趣Action目前的狀態，通常會在MonoBehaviour script中的Update()方法去做輪詢。 Event-driven(事件驅動)：Event-driven則是建立要執行的方法，當Action執行時，就會自動呼叫並執行。 Polling在大部分的場景，特別是動作遊戲，使用者的輸入必須平滑順暢的控制遊戲中的角色，使用Polling通常是比較容易去實作。 使用InputAction提供的ReadValue&lt;&gt;()便可以取得目前Action的值 12345678910111213141516171819using UnityEngine;using UnityEngine.InputSystem;public class Example : MonoBehaviour{ InputAction moveAction; private void Start() { moveAction = InputSystem.actions.FindAction(&quot;Move&quot;); } void Update() { // 取得action的值 Vector2 moveValue = moveAction.ReadValue&lt;Vector2&gt;(); // 取得值之後，便可以將其應用到GameObject上，讓其移動。 }} 方法 描述 InputAction.WasPerformedThisFrame() 在當前幀的任何時間點，如果這個Action在InputAction.phase曾經變為「已執行」(Performed)，則為True。 InputAction.WasCompletedThisFrame() 在當前幀的任何時間點，如果這個Action在InputAction.phase曾經從「已執行」(Performed)更改為任何其他階段(phase)，則為True。這對於按鈕那些具有「按下」(Press) 或「按住」(Hold)等動作非常有用，當按住時，返回的為False。Pass-Through 以下程式碼使用了預設的Interact Action，它包含一個「按住」(Hold)交互(interaction)，使得只有綁定的控件被按住一段時間 (例如 0.4 秒) 後才會執行該動作。 12345678910111213141516171819202122232425using UnityEngine;using UnityEngine.InputSystem;public class Example : MonoBehaviour{ InputAction interactAction; private void Start() { interactAction = InputSystem.actions.FindAction(&quot;Interact&quot;); } void Update() { if (interactAction.WasPerformedThisFrame()) { // 在此執行的程式碼滿足：Interact action按住足夠長時間的第一幀 } if (interactAction.WasCompletedThisFrame()) { // 在此執行的程式碼滿足：Interact action被按住足夠長時間後釋放的那一幀 } }} 以下方法可以用來輪詢按鈕是否被按下或是釋放 方法 描述 InputAction.IsPressed() 如果Action的「動作水平(the level of actuation)」已經超過「按下壓力點(press point)」，並且尚未下降或低於「釋放臨界點(release threshold)」，則為True。 InputAction.WasPressedThisFrame() 如果Action的「動作水平(the level of actuation)」在當前幀的任何時間點達到或超過「按下壓力點(press point)」，則為True。 InputAction.WasReleasedThisFrame() 如果Action的「動作水平(the level of actuation)」在當前幀的任何時間點，在「按下壓力點(press point)」以上或是或低於「釋放臨界點(release threshold)」，則為True。 以下範例有三個Actions，分別為Shield，Teleport與Submit(它們不是預設的action) 123456789101112131415161718192021222324252627282930313233using UnityEngine;using UnityEngine.InputSystem;public class Example : MonoBehaviour{ InputAction shieldAction; InputAction teleportAction; InputAction submitAction; private void Start() { shieldAction = InputSystem.actions.FindAction(&quot;Shield&quot;); teleportAction = InputSystem.actions.FindAction(&quot;Teleport&quot;); submitAction = InputSystem.actions.FindAction(&quot;Submit&quot;); } void Update() { if (shieldAction.IsPressed()) { // shield會在shield action被按下的每一幀都處於激活狀態 if (teleportAction.WasPressedThisFrame()) { // teleport會在 按下動作的第一幀 發生，直到 按鈕釋放 後才會再次生效。 } if (submit.WasReleasedThisFrame()) { // submit會在 動作釋放的幀 發生，這是一種常用于 UI 控制按鈕的常見技巧。 } }} Event-driven可以為Action註冊一些callback，當某些輸入發生時，Action就會通知你，讓你可以做出相應的回應。有以下方式可以使用callback 透過PlayerInput Component註冊callback 使用Action的started，performed與canceled callback 使用ActionMap的actionTriggered callback 使用Input System的全域InputSystem.onActionChange callback InputActionTrace可以記錄Actions上的改變 PlayerInput Component使用PlayerInput component可以在inspector中直接設定callback。此外也可以透過程式碼來設定 Phase(階段) 描述 Disabled 此Action已停用且無法接收輸入 Waiting 此Action已啟用且等待輸入 Started Input System已接收到輸入並開始與Action互動 Performed 與Action的互動已經完成 Canceled 與Action的互動已經被取消 Action callbacks可以透過 InputAction.phase 來取得目前的階段，Started，Performed與Canceled階段各有與之關聯的callback函數 12345var action = new InputAction();action.started += context =&gt; {/* Action已經開始 */};action.performed += context =&gt; {/* Action已經執行 */};action.canceled += context =&gt; {/* Action已經取消 */}; 每個callback都會接收一個InputAction.CallbackContext結構，該結構包含上下文信息，您可以利用它來查詢Action的當前狀態，以及讀取觸發該動作的裝置控制的值。 注意：此結構的內容只在callback期間中有效，請勿把它暫存並在callback之外使用。 callback函數的觸發時機和方式取決於綁定中存在的交互 (Interactions)。如果綁定沒有適用的交互，則會應用預設的交互(Default Interaction)。 除了監聽個別Action，你也可以使用InputActionMap.actionTriggered監聽該Map中的全部Action，使用這種方式，該單一個callback會收到started，performed與canceled，且其InputAction.CallbackContext結構與使用個別started，performed與canceled的結構相同。 123456var actionMap = new InputActionMap();actionMap.AddAction(&quot;action1&quot;, &quot;&lt;Gamepad&gt;/buttonSouth&quot;);actionMap.AddAction(&quot;action2&quot;, &quot;&lt;Gamepad&gt;/buttonNorth&quot;);actionMap.actionTriggered += context =&gt; { ... }; InputSystem.onActionChange與InputSystem.onDeviceChange類似，讓你可以全域(globally)監聽任何與Action相關的變更 12345678910111213InputSystem.onActionChange += (obj, change) =&gt; { // obj可能是InputAction或是InputMap，需要依靠change去判斷 switch (change) { case InputActionChange.ActionStarted: case InputActionChange.ActionPerformed: case InputActionChange.ActionCanceled: Debug.Log($&quot;{((InputAction)obj).name} {change}&quot;); break; } } InputActionTrace，你可以使用InputActionTrace為某些特定Action集合建立日誌(log)，讓你可以追蹤它們。 注意：InputActionTrace會使用不受管理的記憶體，因此在使用後要去處理(disposed)它，避免造成記憶體洩漏(memory leak) 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 實體化一個 InputActionTracevar trace = new InputActionTrace();// 為這個Action訂閱trace。// 取消訂閱的話，使用UnsubscribeFrom方法trace.SubscribeTo(myAction);// 為整個Action Map訂閱trace// 取消訂閱的話，使用UnsubscribeFrom方法trace.SubscribeTo(myActionMap);// 為所有在系統中的Action訂閱tracetrace.SubscribeToAll();// 為這個Action紀錄一個觸發myAction.performed += ctx =&gt; { if (ctx.ReadValue&lt;float&gt;() &gt; 0.5f) trace.RecordAction(ctx); };// 輸出這個traceDebug.Log(string.Join(&quot;,\\n&quot;, trace));// 拜訪所有Action的trace紀錄，之後清除trace。foreach (var record in trace){ Debug.Log($&quot;{record.action} was {record.phase} by control {record.control}&quot;); // 讀取這個紀錄的值，你需要知道它的類型是什麼，否則你可以把它讀為一般的Byte。此處假設他是float Debug.Log(&quot;Value: &quot; + record.ReadValue&lt;float&gt;()); // 如果願意接受GC負擔，也可以將值讀取為物件(object)。 // 此時，你可以不需要知道它的類型 Debug.Log(&quot;Value: &quot; + record.ReadValueAsObject());}trace.Clear();// 取消所有追蹤的訂閱。trace.UnsubscribeFromAll();// 釋放trace使用的記憶體trace.Dispose(); 一旦紀錄完成，只要不同時進行寫入操作，並且主線程上不會同時變更Action設置，則trace可以安全地從多個線程讀取。 Action typesAction有三種類型，這些類型會影響Input System如何處理操作Action的狀態。 Action Type 描述 Value 預設的Action Type。適用於任何需要追踪控制項(Control)狀態連續變化的輸入。Value action Type 會持續監控所有綁定到該動作(Action)的控制項(Control)，然後選擇最活躍(actuated)的控制項作為驅動該動作的控制項，並在值發生變化時觸發回調函式(callback)報告該控制項的值。如果另一個綁定控制項的活躍程度更高，那麼該控制項就會成為驅動動作的控制項，動作會開始報告該控制項的值。這個過程稱為 衝突解決 (conflict resolution)。如果您希望允許遊戲中不同的控制項控制一個動作，但僅同時從一個控制項接收輸入，那麼這將非常有用。當動作(action)首次啟用時，它會對所有綁定控制項(Control)執行 初始狀態檢查(initial state check)。如果任何一個控制項被激活，則動作會觸發一個回調，傳遞當前值。 Button Button類型非常類似於Value類型，但有以下幾點不同：Button類型的動作只能綁定到「按鈕控制項」(ButtonControl)。與Value類型的動作不同，Button類型的動作不會執行初始狀態檢查。「按鈕」類型的動作適用於每次按下時觸發一次操作的輸入。在這種情況下，初始狀態檢查通常沒有用，因為它可能會在啟用動作時，因之前按住按鈕而觸發動作 (即按鈕仍然處於按下狀態)。 PassThrough PassThrough類型的動作與上面描述的Value動作不同，它繞過了衝突解決。PassThrough類型的動作不會選擇一個特定的控制項作為驅動動作的來源。 相反，任何綁定的控制項會變更都會觸發一個回調，並將該控制項的目前值傳遞給回調函數。PassThrough類型的動作適用於您想要處理來自一組控制項的所有輸入的情況。 使用Input Debugger，可以觀察目前啟用的Action以及與他們綁定的Control。也可以使用InputActionVisualizer在螢幕上即時可視化動作的值和交互狀態。 上一篇：Actions概念 Reference: https://docs.unity3d.com/Packages/com.unity.inputsystem@1.8/manual/RespondingToActions.html","link":"/2024/04/26/%E4%BD%BF%E7%94%A8Action/"},{"title":"使用UQuery來查找element","text":"UQuery受到JQuery與Linq啟發，UQuery被設計為會限制動態記憶體分配(dynamic memory allocation)，讓手機平台上可以擁有最佳化的效能。可以使用Query和Q(Q是Query&lt;T&gt;.First()的縮寫)這兩個extension method來使用UQuery。 Q與Query實際上是使用UQueryBuilder來建構一個query，這些extension method可以減少在建立UQueryBuilder時需要撰寫的模板程式碼。 在使用UQuery之前，你必須要先載入並實體化UXML，然後才能用Q或Query建立選取規則(selection rules) 透過選擇規則返回的elements你還可以使用UQueryBuilder上的First，Last， AtIndex，Children與Where公開方法(public method)來更進一步的過濾它們。 可以透過element的name，USS class，element type (C# type)來找到想要的element。 也可以使用predicate或是組合[複雜結構的query](#Complex hierarchical queries)來找到想要的element UQuery會在初始化時Cache這些選出來的Elements。 UI Toolkit不會自行銷毀沒用到的visual elements，它是使用C# garbage collector 來處理，因此最好不要在UIDocuments或Window之外建立這些elements的引用，避免讓C# garbage collector無法回收。 以下使用一個UXML來說明 1234567891011121314&lt;UXML xmlns=&quot;UnityEngine.UIElements&quot;&gt; &lt;VisualElement name=&quot;container1&quot;&gt; &lt;Button name=&quot;OK&quot; text=&quot;OK&quot; /&gt; &lt;Button name=&quot;Cancel&quot; text=&quot;Cancel&quot; /&gt; &lt;/VisualElement&gt; &lt;VisualElement name=&quot;container2&quot;&gt; &lt;Button name=&quot;OK&quot; class=&quot;yellow&quot; text=&quot;OK&quot; /&gt; &lt;Button name=&quot;Cancel&quot; text=&quot;Cancel&quot; /&gt; &lt;/VisualElement&gt; &lt;VisualElement name=&quot;container3&quot;&gt; &lt;Button name=&quot;OK&quot; class=&quot;yellow&quot; text=&quot;OK&quot; /&gt; &lt;Button name=&quot;Cancel&quot; class=&quot;yellow&quot; text=&quot;Cancel&quot; /&gt; &lt;/VisualElement&gt;&lt;/UXML&gt; Query by name語法為： Query(name: &quot;element-name&quot;) 或是 Q(name: &quot;element-name&quot;) ；你也可以省略參數名稱name，直接使用Query(&quot;element-name&quot;) 12// 這句會回傳所有name為OK的element。List&lt;VisualElement&gt; result = root.Query(&quot;OK&quot;).ToList(); 1234// 這句會回傳找到name為OK的第一個element。VisualElement result = root.Query(&quot;OK&quot;).First();// 你也可以直接寫QVisualElement result = root.Q(&quot;OK&quot;); 12// 這句是選name為OK的第二個element（第一個element的index是0）VisualElement result3 = root.Query(&quot;OK&quot;).AtIndex(1); 12// 這句是選name為OK的最後一個elementVisualElement result4 = root.Query(&quot;OK&quot;).Last(); Query by USS class語法為：Query(className: &quot;class-name&quot;) 或是 Q(className: &quot;class-name&quot;) 12// 這句會選出所有class name為yellow的elementList&lt;VisualElement&gt; result = root.Query(className: &quot;yellow&quot;).ToList(); 12// 這句會選class name為yellow的第一個elementVisualElement result = root.Q(className: &quot;yellow&quot;); Query by element type語法為：Query&lt;Type&gt;() 或是 Q&lt;Type&gt;() 注意：你只能使用actual type來選出Element，而不能使用base type。 1234// 這句會選出第一個Button elementVisualElement result = root.Q&lt;Button&gt;();// 將這個button的tooltip更改result.tooltip = &quot;This is a tooltip!&quot;; 12// 這句會選出第三個Button elementVisualElement result = root.Query&lt;Button&gt;().AtIndex(2); Query with a predicate除了可以使用name，class-name，type來選出element以外，還可以搭配Where做更進一步的篩選，Where的參數是一個VisualElement。 12// 這句會選出所有class name為yellow的element，然後在找出tooltip為空字串的elementList&lt;VisualElement&gt; result = root.Query(className: &quot;yellow&quot;).Where(elem =&gt; elem.tooltip == &quot;&quot;).ToList(); Complex hierarchical queries可以將name，class-name，type等組合在一起，做更複雜的選擇。 12// 這句將name，type，class-name做組合，選出class-name為yellow，name為OK的Button elementVisualElement result = root.Query&lt;Button&gt;(className: &quot;yellow&quot;, name: &quot;OK&quot;).First(); 12// 這句將選出container2中所有name為Cancel的Button elementVisualElement result = root.Query&lt;VisualElement&gt;(&quot;container2&quot;).Children&lt;Button&gt;(&quot;Cancel&quot;).First();","link":"/2024/04/12/%E4%BD%BF%E7%94%A8UQuery%E4%BE%86%E6%9F%A5%E6%89%BEelement/"},{"title":"使用grep在多個檔案中找出含有某個字串的檔案","text":"有時候會想在很多個檔案中找出是否含有某個字串，這時可以使用grep 會找 /etc/ 目錄下檔案內容含有 like 的檔案，例如：like與liked。 1grep -nr &quot;like&quot; /etc/ 會找 /etc/目錄下檔案內容含有 like 單字 的檔案，與上面的差異為加上-w之後，只匹配單詞like，而不是像liked這樣的子字串。 1grep -rnw '/like' /etc/ 加上-i之後，會忽略大小寫。可以匹配到LIKE，Liked，或是like…等 1grep -rni '/like' /etc/ 以下是常用的參數 12345-n 會印出關鍵字在檔案的行數-r 會遞迴的找子資料夾-w 只匹配一個單字-y 忽略大小寫-i 忽略大小寫","link":"/2024/04/19/%E4%BD%BF%E7%94%A8grep%E5%9C%A8%E5%A4%9A%E5%80%8B%E6%AA%94%E6%A1%88%E4%B8%AD%E6%89%BE%E5%87%BA%E5%90%AB%E6%9C%89%E6%9F%90%E5%80%8B%E5%AD%97%E4%B8%B2%E7%9A%84%E6%AA%94%E6%A1%88/"},{"title":"依賴(dependency)","text":"依賴（Dependency）：通常指的是一個類別依賴於另一個類別或介面來完成其功能。 依賴使得類別之間的耦合度增加，讓系統變得難以維護和測試。 依賴關係的方向性可以分為單向依賴(Unidirectional Dependency)和雙向依賴(Bidirectional Dependency)。 單向依賴(Unidirectional Dependency)：是指一個類別或模組依賴於另一個類別或模組，但相反的依賴關係不存在。這種依賴關係是單向的，即依賴的方向是單一的，這種依賴的程式碼較容易維護和擴展。 在下面例子中，Car 類別依賴於 Engine 類別，但 Engine 類別並不依賴 Car 類別。這就是一個單向依賴的例子。12345678910111213141516171819202122public class Engine{ public void Start() { Console.WriteLine(&quot;Engine started.&quot;); }}public class Car{ private Engine _engine; public Car(Engine engine) { _engine = engine; } public void Start() { _engine.Start(); }} 雙向依賴(Bidirectional Dependency)：是指兩個類別或模組互相依賴，形成了雙向的依賴關係。這種依賴關係會增加系統的耦合度，使得程式碼難以維護和測試。 通常在設計中應該盡量避免雙向依賴，或者使用依賴注入和接口等技術來減少耦合度。 在這個例子中，Engine 類別依賴於 Car 類別，並且 Car 類別也依賴於 Engine 類別，形成了雙向依賴。這種設計會使得類別之間的關係變得複雜，難以維護和測試。1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Engine{ private Car _car; public Engine(Car car) { _car = car; } public void Start() { Console.WriteLine(&quot;Engine started.&quot;); _car.NotifyEngineStarted(); }}public class Car{ private Engine _engine; public Car() { _engine = new Engine(this); } public void Start() { _engine.Start(); } public void NotifyEngineStarted() { Console.WriteLine(&quot;Car notified: Engine started.&quot;); }}public class Program{ public static void Main(string[] args) { Car car = new Car(); car.Start(); }}","link":"/2024/05/25/%E4%BE%9D%E8%B3%B4-dependency/"},{"title":"合成並發送事件(Synthesize and send events)","text":"事件系統使用一個事件池(pool of events)，以避免重複分配事件物件(event object)。要合成並發送自己的事件需要： 建立一個UnityEngine.Event用來持有初始化的資料 從事件池中獲取一個事件物件。 填寫事件的屬性(event properties)。 將事件封裝在using區塊中，以確保它被返回到事件池。 將事件傳遞給panel.visualTree.SendEvent()。 下面的例子中會發送一個KeyDownEvent 1234567891011121314151617void SynthesizeAndSendKeyDownEvent(IPanel panel, KeyCode code, char character = '\\0', EventModifiers modifiers = EventModifiers.None){ // 建立一個UnityEngine.Event用來持有初始化的資料 var evt = new Event() { type = EventType.KeyDownEvent, keyCode = code, character = character, modifiers = modifiers }; // 將事件封裝在`using`區塊中，以確保它被返回到事件池 using (KeyDownEvent keyDownEvent = KeyDownEvent.GetPooled(evt)) { panel.visualTree.SendEvent(keyDownEvent); }} 注意： 不能發送不是來自OS(operating system)的事件， 不能發送不在UnityEngine.Event types中的事件 某些事件是由UI Toolkit作為對內部狀態變化的反應而發送的，不應由外部過程發送。例如，如果您發送PointerCaptureEvent，visual elements會假定該事件的底層條件已滿足，並且不會為它們設置指針捕獲(pointer capture)。這可能會破壞visual elements的內部配置(configurations)並導致未定義的行為。 Event reference Reference: https://docs.unity3d.com/Manual/UIE-Events-Synthesizing.html","link":"/2024/04/19/%E5%90%88%E6%88%90%E4%B8%A6%E7%99%BC%E9%80%81%E4%BA%8B%E4%BB%B6-Synthesize-and-send-events/"},{"title":"焦點事件(Focus events)","text":"當你需要把焦點移到某個visual element或移開時，可以使用Focus event。 Focus events分為兩種不同的類型： FocusOutEvent與FocusInEvent：在焦點發生變化之前，焦點離開事件（FocusOutEvent）和焦點進入事件（FocusInEvent）會沿著事件傳播路徑(propagation path)發送。 FocusEvent與BlurEvent：焦點事件（FocusEvent）和失焦事件（BlurEvent）會在焦點發生變化後立即發送到事件目標(event target) Event 描述 Trickles down Bubbles up Cancellable FocusOutEvent 在失去焦點之前，會發送一個FocusOutEvent ✔ ✔ FocusInEvent 在element取得焦點之前，會發送一個FocusInEvent ✔ ✔ BlurEvent 在失去焦點之後，會發送一個BlurEvent ✔ FocusEvent 在element取得焦點之後，會發送一個FocusEvent ✔ 專屬於Focus Event的屬性 relatedTarget：在焦點事件中參與的第二個target element。 對於FocusOutEvent與BlurEvent，這個屬性為聚焦的element。 對於FocusInEvent與FocusEvent，這個屬性為失去焦點的element。 Event target relatedTarget BlurEvent 失去焦點的element 取得焦點的element FocusEvent 取得焦點的element 失去焦點的element FocusInEvent 取得焦點的element 失去焦點的element FocusOutEvent 失去焦點的element 取得焦點的element 例子：使用FocusInEvent與FocusOutEvent為TextField實現placeholder text功能 在Assets &gt; Scripts &gt; Editor 下建立一個 C# Script PlaceHolderExample.cs 將以下程式碼複製到剛剛建立的C# Script中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748using UnityEditor;using UnityEngine;using UnityEngine.UIElements;public class PlaceHolderExample : EditorWindow{ // 這個Attributes會在 Windows -&gt; UI Tollkit 下加入一個 PlaceHolderExample [MenuItem(&quot;Window/UI Toolkit/PlaceHolderExample&quot;)] public static void ShowExample() { PlaceHolderExample wnd = GetWindow&lt;PlaceHolderExample&gt;(); wnd.titleContent = new GUIContent(&quot;PlaceHolderExample&quot;); } private bool placeHolderMode = true; private const string placeHolderText = &quot;Write here&quot;; public void CreateGUI() { // 建立 TextField TextField textField = new TextField(); textField.value = placeHolderText; rootVisualElement.Add(textField); // 註冊FocusInEvent與FocusOutEvent textField.RegisterCallback&lt;FocusInEvent&gt;(OnFocusInTextField); textField.RegisterCallback&lt;FocusOutEvent&gt;(OnFocusOutTextField); } private void OnFocusInTextField(FocusInEvent evt) { // 如果這個 text field 收到聚焦，表示使用者想要輸入字串，因此要將placeholder文字清空 if (placeHolderMode) { var textField = evt.target as TextField; textField.value = &quot;&quot;; } } private void OnFocusOutTextField(FocusOutEvent evt) { // 如果這個 text field 失焦，表示使用者已經完成輸入，但如果text field為空字串，則要將placeholder文字填回去。 var textField = evt.target as TextField; placeHolderMode = string.IsNullOrEmpty(textField.value); if (placeHolderMode) textField.value = placeHolderText; }} 在Unity編輯器中找到 Window &gt; UI Toolkit &gt; PlaceHolderExample Reference: https://docs.unity3d.com/Manual/UIE-Focus-Events.html","link":"/2024/04/22/%E5%91%BD%E4%BB%A4%E4%BA%8B%E4%BB%B6-Command-events/"},{"title":"在Chrome中抓取整個網頁截圖","text":"打開 DevTools，在右邊找到 Run command。點擊之後，輸入Capture full size screenshot就可以抓取該網頁的截圖了","link":"/2024/02/08/%E5%9C%A8Chrome%E4%B8%AD%E6%8A%93%E5%8F%96%E6%95%B4%E5%80%8B%E7%B6%B2%E9%A0%81%E6%88%AA%E5%9C%96/"},{"title":"委派 Delegate","text":"委派：delegate 它的本質上是一個Class，主要用來定義method的類型 可以把它想像為一個定義method容器，用來儲存要傳遞的method。 使用委派讓你可以在呼叫method先處理一些邏輯，當這些邏輯處理完之後，在傳入這些method。 以下是他的語法 1存取修飾詞 delegate 返回值 委派名(參數列表); 如果沒寫存取修飾詞的話，預設為public的， 若取修飾詞寫為private的話，則其他namespace不可以使用 委派的method參數必須要對應 宣告範例 12345// 定義了一個無參無返回值容器 MyFundelegate void MyFun();// 定義了一個返回值為int，有一個int參數的委派容器delegate int MyFun2(int a); 使用範例 123456789101112131415161718192021222324252627282930313233delegate void MyFun();delegate int MyFun2(int a);class Program{ static void Main() { Console.WriteLine(&quot;委派&quot;); // 裝載method的容器 MyFun f = new MyFun(Fun); // 呼叫容器裡面的method f.Invoke(); // 簡化寫法，與f的方式一樣 MyFun f2 = Fun; f2(); // 容器與委派的method參數必須要對應 MyFunc2 f3 = Fun2; f3(1); } static void Fun() { Console.WriteLine(&quot;123456&quot;); } static int Fun2(int value) { Console.WriteLine(value); return value; }} C#預設先定義的委派 Action：是一個無參無返回值的委派 Func：一個無參數，但有一個返回泛型TResult的委派 Action(T obj)可以傳多個參數(最多有16個，是使用overload的方式)，無返回的委派 Func&lt;in T, out TResult&gt;(T arg); 可以傳多個參數，且有一個返回泛型TResult的委派 記憶方式：Func是有返回值的委託，而Action則是不會返回值的委託 Action例子 1234567Action&lt;int, string&gt; action = FunTest;static void FunTest(int a, string b) { // do something...} Func例子 1234567Func&lt;int, int&gt; func = FunTest2;static int FunTest2(int value) { Console.WriteLine(value); return value;}","link":"/2024/02/09/%E5%A7%94%E6%B4%BE-Delegate/"},{"title":"將Animator包裝起來避免使用String輸入錯誤","text":"在Unity中，使用Animator時，有時候會打錯字，造成找不到動畫，因此可以使用一個包裝類，將其包裝起來。 首先建立一個抽象類，AnimatorWrapper，在其中加入Animator依賴。 123456789namespace Test{ public abstract class AnimatorWrapper { protected Animator _animator; public Animator Animator =&gt; _animator; public AnimatorWrapper(Animator animator) =&gt; _animator = animator; }} 接著再需要播放動畫的物件實作對應的AnimatorWrapper類，將string參數放到這邊。 123456789namespace Test{ public class DoorAnimatorWrapper : AnimatorWrapper { public DoorAnimatorWrapper(Animator animator) : base(animator) { } public void IsOpen(bool isOpen) =&gt; _animator.SetBool(&quot;Open&quot;, isOpen); }} 在使用時，透過AnimatorWrapper類曝露出來的IsOpen去操作animator。 123456789private DoorAnimatorWrapper _animatorWrapper;private void Awake(){ var animator = GetComponent&lt;Animator&gt;(); _animatorWrapper = new DoorAnimatorWrapper(animator);}private void OpenDoor(bool isOpen) =&gt; _animatorWrapper.IsOpen(isOpen); 透過這種方式它能夠幫助減少因為打錯字符串而導致的錯誤，並提供了一個更加直觀、安全的介面來操作 Animator。 參考：Typos with string animation parameters","link":"/2024/04/02/%E5%B0%87Animator%E5%8C%85%E8%A3%9D%E8%B5%B7%E4%BE%86%E9%81%BF%E5%85%8D%E4%BD%BF%E7%94%A8String%E8%BC%B8%E5%85%A5%E9%8C%AF%E8%AA%A4/"},{"title":"事件捕捉(Capture events)","text":"事件捕捉(Capture events)通知你滑鼠捕捉狀態(mouse capture state)的變化，在UI Toolkit中的事件有兩捕捉種類型： 滑鼠捕捉事件(Mouse capture events) 指標捕捉事件(Pointer capture events) 當一個element捕捉了滑鼠或指標，它是唯一接收來自點擊裝置(Pointing device，如滑鼠)事件的element，直到該裝置釋放或失去捕捉為止。例如：假設你使用滑鼠點擊了一個文字框(text box)，這個文字框會捕捉這個滑鼠，此時滑鼠仍然可以移動，但是它不會觸發文字框之外的事件；只要這個文字框正在捕捉你的滑鼠，那麼它就不會觸發其他事件。當你在文字框之外按下滑鼠上的按鈕時，文字框會釋放其滑鼠捕捉。 捕捉滑鼠(Mouse capture)滑鼠捕捉事件(Mouse capture events)是實體滑鼠或是模擬滑鼠的虛擬滑鼠上的事件。捕捉到滑鼠時，也會產生一個滑鼠指標的PointerCaptureEvent。當一個element釋放捕捉滑鼠時，會觸發相應的MouseCaptureOutEvent。 注意：不會發生同時有兩個elements同時捕捉滑鼠的情況，如果另外一個Visual Element觸發了MouseCaptureEvent那麼原先捕捉滑鼠的Element就會釋滑鼠並收到一個MouseCaptureOutEvent 捕捉指標(Pointer capture)在UI Toolkit中，指標事件優先於滑鼠事件。如果指標的類型是滑鼠的話，在捕捉到指標事件時也會觸發滑鼠事件。 Event 描述 Trickles down Bubbles up Cancellable MouseCaptureEvent 當某個Element被滑鼠捕捉時會發送這個事件，此時target為這個Element ✔ ✔ MouseCaptureOutEvent 當某個Element捕捉的滑鼠被釋放或是某些其他原因是放時，會發送這個事件，此時target為這個失去滑鼠捕捉的Element ✔ ✔ PointerCaptureEvent 當某個Element捕捉指標時會發送這個事件，此時target為這個Element ✔ ✔ PointerCaptureOutEvent 當某個Element捕捉的指標被釋放時，會發送這個事件，此時target為這個失去指標捕捉的Element ✔ ✔ 例子以下例子為示範捕捉與釋放的行為 在Assets &gt; Scripts &gt; Editor 下建立一個 C# Script CaptureEventsTestWindow.cs 將以下程式碼複製到剛剛建立的C# Script中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465using UnityEditor;using UnityEngine;using UnityEngine.UIElements;public class CaptureEventsTestWindow : EditorWindow{ // 這個Attributes會在 Windows -&gt; UI Tollkit 下加入一個 Capture Events Test Window [MenuItem(&quot;Window/UI Toolkit/Capture Events Test Window&quot;)] public static void ShowExample() { var wnd = GetWindow&lt;CaptureEventsTestWindow&gt;(); wnd.titleContent = new GUIContent(&quot;Capture Events Test Window&quot;); } private bool m_IsCapturing = false; public void CreateGUI() { for (int i = 0; i &lt; 4; i++) { // 建立一個 Label 的Visual Element Label clickableLabel = new Label($&quot;Label {i} - Click Me!&quot;); // 為這個Label Element註冊 MouseDownEvent clickableLabel.RegisterCallback&lt;MouseDownEvent&gt;((evt) =&gt; { // 這個匿名Callback會在Console中印出 Clicked on label *** 的字串 Debug.Log($&quot;Clicked on label '{(evt.target as Label).text}'&quot;); }); rootVisualElement.Add(clickableLabel); } // 建立一個 Label 的Visual Element Label capturingLabel = new Label(&quot;Click here to capture mouse&quot;); // 為這個Label Element註冊 MouseDownEvent capturingLabel.RegisterCallback&lt;MouseDownEvent&gt;((evt) =&gt; { if (!m_IsCapturing) { capturingLabel.text = &quot;Click here to release mouse&quot;; // 捕捉滑鼠 MouseCaptureController.CaptureMouse(capturingLabel); m_IsCapturing = true; } else { capturingLabel.text = &quot;Click here to capture mouse&quot;; // 釋放捕捉 MouseCaptureController.ReleaseMouse(capturingLabel); m_IsCapturing = false; } }); rootVisualElement.Add(capturingLabel); // 註冊捕捉滑鼠事件 rootVisualElement.RegisterCallback&lt;MouseCaptureEvent&gt;((evt) =&gt; { Debug.Log(&quot;Mouse captured&quot;); }); // 註冊滑鼠釋放捕捉事件 rootVisualElement.RegisterCallback&lt;MouseCaptureOutEvent&gt;((evt) =&gt; { Debug.Log(&quot;Mouse captured released&quot;); }); }} 在Unity編輯器中找到 Window &gt; UI Toolkit &gt; Capture Events Test Window 點擊Test Window上面的Label來觀看結果 Reference： https://docs.unity3d.com/Manual/UIE-Change-Events.html","link":"/2024/04/20/%E6%8D%95%E6%8D%89%E4%BA%8B%E4%BB%B6-Capture-events/"},{"title":"暴露自訂control給UXML","text":"自訂control需要繼承VisualElement並且這個自訂control需要有一個預設constructor1234567891011class StatusBar : VisualElement{ // 需要有一個預設constructor public StatusBar() { m_Status = String.Empty; } string m_Status; public string status { get; set; }} 為了讓你自訂的control可以在UXML中使用，你需要定義一個factory class，如果沒有特殊的需求，可以直接繼承UxmlFactory&lt;T&gt;1234567class StatusBar : VisualElement{ // 建議直接將factory class放在自訂的control中 public new class UxmlFactory : UxmlFactory&lt;StatusBar&gt; {} // ...} UxmlTraits：定義在UXML中可以使用的特徵(UXML traits)， UxmlTraits的目的有 factory建立新物件時使用它們。 在schema產生時，會分析它們以取得關於該Element的資訊，之後將這些資訊轉換為XML schema directive。 以下範例 宣告了一個m_Status，用來定義一個XML attribute status uxmlChildElementsDescription回傳一個空IEnumerable，用來表明這個自訂的StatusBar沒有child。 Init()中，XML parser從property bag讀出的值設定給StatusBar.status UxmlTraits class定義在StatusBar class中，讓Init()可以存取StatusBar的私有變數。 UxmlTraits繼承了VisualElement.UxmlTraits，它也擁有VisualElement.UxmlTraits的屬性 Init()會呼叫base.Init()以初始化base class的屬性 12345678910111213141516171819202122class StatusBar : VisualElement{ public new class UxmlFactory : UxmlFactory&lt;StatusBar, UxmlTraits&gt; {} public new class UxmlTraits : VisualElement.UxmlTraits { UxmlStringAttributeDescription m_Status = new UxmlStringAttributeDescription { name = &quot;status&quot; }; public override IEnumerable&lt;UxmlChildElementDescription&gt; uxmlChildElementsDescription { get { yield break; } } public override void Init(VisualElement ve, IUxmlAttributes bag, CreationContext cc) { base.Init(ve, bag, cc); ((StatusBar)ve).status = m_Status.GetValueFromBag(bag, cc); } } // ...} - 注意：在UI Builder中創作時，UI Builder可能會多次呼叫`UxmlTraits.Init()`來同步UXML檔案中的值，建議使用`GetValueFromBag`而不是`TryGetValueFromBag`以確保當UI Builder取消設定(unset)element的值時，這個element不會殘留先前的值。 若想要有child的話，需要override uxmlChildElementsDescription，1234567public override IEnumerable&lt;UxmlChildElementDescription&gt; uxmlChildElementsDescription{ get { yield return new UxmlChildElementDescription(typeof(VisualElement)); }} 可以將你自訂的control放到namespace中來分類它們12[assembly: UxmlNamespacePrefix(&quot;My.First.Namespace&quot;, &quot;first&quot;)][assembly: UxmlNamespacePrefix(&quot;My.Second.Namespace&quot;, &quot;second&quot;)] Reference:https://docs.unity3d.com/Manual/UIE-expose-custom-control-to-uxml.html#define-a-factory","link":"/2024/05/01/%E6%9A%B4%E9%9C%B2%E8%87%AA%E8%A8%82control%E7%B5%A6UXML/"},{"title":"泛型約束","text":"泛型約束是使用where關鍵字讓泛型的類型有一定的限制 where T:struct ：結構類型的約束，只能接收結構類型作為泛型 12345678910class Test1&lt;T&gt; where T:struct{ public T value; public void TestFun&lt;K&gt;(K v) where K: struct}// 這句會報錯，因為他不是結構類型//-- Test1&lt;object&gt; t = new Test1&lt;object&gt;();// 這句可以Test1&lt;int&gt; t2 = new Test1&lt;int&gt;(); where T:class ：引用類型約束 1234567891011class Test2&lt;T&gt; where T : class{ public T value; public void TestFun&lt;K&gt;(K k) where K : class {}}// 這句可以Test2&lt;object&gt; t = new Test2&lt;object&gt;();// 這句會報錯，因為 int 不是引用類型//-- Test2&lt;int&gt; t2 = new Test2&lt;int&gt;(); where T: new() ：這個泛型一定要有一個無參數public的建構子(constructor)，此外若是組合使用的話new()要放到最後 12345678910111213141516class Test3&lt;T&gt; where T : new(){ public T value;}class PubC1 {}class PubC2{ public PubC2(int i) {}}// 這句可以Test3&lt;PubC1&gt; t = new Test3&lt;PubC1&gt;();// 這句不可以，因為 PubC2 沒有無參數的 public 建構子//-- Test3&lt;PubC2&gt; t2 = new Test3&lt;PubC2&gt;(); where T: 類名 ：泛型參數必須要是其類或者是其子類 where T: 介面名 ：泛型參數必須要是其介面的衍伸類型 where T:U：泛型參數為另一個泛型本身或是其衍伸類型 123class Test6&lt;T,U&gt; where T:U{ public T value;} 多個泛型皆有約束 1class Test8&lt;K,V&gt; where K:class,new() where K:struct{}","link":"/2024/05/25/%E6%B3%9B%E5%9E%8B%E7%B4%84%E6%9D%9F/"},{"title":"變更事件(Change events)","text":"當一個Element的值改變時，就會發送一個Change Event，例如使用者切換了(toggles)一個核取方塊(Checkbox)，Change Event是一個帶有類型的事件(Typed Event)，它含有這個Element先前的值和新值。由於Change Event是在新的值被賦值後才觸發，因此你無法透過取消Change Event的方式去來避免值的改變。 Event 描述 Trickles down Bubbles up Cancellable ChangeEvent 當一個Element的值改變時，就會發送一個Change Event ✔ ✔ 專屬於Change Event的屬性 previousValue: 存放該Element先前的值 The previous value of the target control. newValue: 存放該Element該要改變的新值 Change Event是一個通知事件(notification event)讓你可以在visual element的值改變時做出反應，例如：當使用者按下音樂核取方塊(Checkbox)那麼遊戲的音樂就應該都被關閉。 Change Event應用到所有有實作INotifyValueChanged&lt;T&gt;的controls其中&lt;T&gt;就是ChangeEvent，此外這個也被在內部使用，透過Data binding的方式來更新實體物件的屬性 避免觸發Change Event如果你是透過程式碼更改control的值而觸發control的Change Event，你可以透過呼叫INotifyValueChange&lt;T&gt;中的SetValueWithoutNotify來更改control的值，並避免觸發Change Event 註冊Change Event 呼叫在Visual Element上的RegisterCallback&lt;&gt;() 如果你想要在一個Element中監聽它的子Elements中是否有發生改變的話，可以使用12345678// 使用RegisterCallback註冊callbackrootVisualElement.RegisterCallback&lt;ChangeEvent&lt;bool&gt;&gt;(OnBoolChangedEvent);// callback方法，它會監聽bool值是否發生改變private void OnBoolChangedEvent(ChangeEvent&lt;bool&gt; evt) { // Handling code} 呼叫有實作INotifyValueChange的Visual Element上的RegisterValueChangedCallback() 使用RegisterValueChangedCallback會比較方便因為它已經內建(build-in)好要傳值得類型 取消註冊可以使用UnregisterValueChangedCallback123456var newToggle = new Toggle(&quot;Test Toggle&quot;);newToggle.RegisterValueChangedCallback(OnTestToggleChanged);private void OnTestToggleChanged(ChangeEvent&lt;bool&gt; evt){ // Handling code} 例子一：註冊兩個ChangeEvent，一個在toggle element上使用RegisterValueChangedCallback，另外一個在root element使用RegisterCallback以下例子為示範如何使用ChangeEvent 在Assets &gt; Scripts &gt; Editor 下建立一個 C# Script ChangeEventTestWindow.cs 將以下程式碼複製到剛剛建立的C# Script中123456789101112131415161718192021222324252627282930313233343536373839using UnityEditor;using UnityEngine;using UnityEngine.UIElements;public class ChangeEventTestWindow : EditorWindow{ private Toggle m_MyToggle; // 這個Attributes會在 Windows -&gt; UI Tollkit 下加入一個 Change Event Test Window [MenuItem(&quot;Window/UI Toolkit/Change Event Test Window&quot;)] public static void ShowExample() { ChangeEventTestWindow wnd = GetWindow&lt;ChangeEventTestWindow&gt;(); wnd.titleContent = new GUIContent(&quot;Change Event Test Window&quot;); } public void CreateGUI() { // 建立一個 toggle control m_MyToggle = new Toggle(&quot;Test Toggle&quot;) { name = &quot;My Toggle&quot; }; rootVisualElement.Add(m_MyToggle); // 使用RegisterValueChangedCallback為這個 toggle control註冊OnTestToggleChanged m_MyToggle.RegisterValueChangedCallback(OnTestToggleChanged); // 使用RegisterCallback在root element註冊OnBoolChangedEvent，它必須要指定泛型 rootVisualElement.RegisterCallback&lt;ChangeEvent&lt;bool&gt;&gt;(OnBoolChangedEvent); } private void OnBoolChangedEvent(ChangeEvent&lt;bool&gt; evt) { Debug.Log($&quot;Toggle changed. Old value: {evt.previousValue}, new value: {evt.newValue}&quot;); } private void OnTestToggleChanged(ChangeEvent&lt;bool&gt; evt) { Debug.Log($&quot;A bool value changed. Old value: {evt.previousValue}, new value: {evt.newValue}&quot;); }} 在Unity編輯器中找到 Window &gt; UI Toolkit &gt; Change Events Test Window 觀看結果 例子二：使用程式碼觸發事件的話，可以透過element上的SetValueWithoutNotify避免觸發Change Event 將以下程式碼覆蓋到ChangeEventTestWindow.cs Script中12345678910111213141516171819202122232425262728293031323334353637383940using UnityEditor;using UnityEngine;using UnityEngine.UIElements;public class ChangeEventTestWindow : EditorWindow{ private Toggle m_MyToggle; [MenuItem(&quot;Window/UI Toolkit/Change Event Test Window&quot;)] public static void ShowExample() { GetWindow&lt;ChangeEventTestWindow&gt;().titleContent = new GUIContent(&quot;Change Event Test Window&quot;); } public void CreateGUI() { // 建立一個toggle並為其註冊callback m_MyToggle = new Toggle(&quot;Test Toggle&quot;) { name = &quot;My Toggle&quot; }; m_MyToggle.RegisterValueChangedCallback((evt) =&gt; { Debug.Log(&quot;Change Event received&quot;); }); rootVisualElement.Add(m_MyToggle); // 建立一個button來更改toggle的值 Button button01 = new Button() { text = &quot;Toggle&quot; }; button01.clicked += () =&gt; { // 這個會觸發Change Event m_MyToggle.value = !m_MyToggle.value; }; rootVisualElement.Add(button01); // 建立另外一個button，但是使用SetValueWithoutNotify更改toggle的值， Button button02 = new Button() { text = &quot;Toggle without notification&quot; }; button02.clicked += () =&gt; { // 使用SetValueWithoutNotify()不會觸發Change Event m_MyToggle.SetValueWithoutNotify(!m_MyToggle.value); }; rootVisualElement.Add(button02); }} 觀看結果 Reference: https://docs.unity3d.com/Manual/UIE-Change-Events.html","link":"/2024/04/21/%E8%AE%8A%E6%9B%B4%E4%BA%8B%E4%BB%B6-Change-events/"},{"title":"身分證字號產生器","text":"","link":"/2024/04/10/%E8%BA%AB%E5%88%86%E8%AD%89%E5%AD%97%E8%99%9F%E7%94%A2%E7%94%9F%E5%99%A8/"},{"title":"自訂control","text":"建立自訂的Control需要建立一個control C# class，然後將它暴露給UXML 建立一個繼承VisualElement的Class 若是要建立可綁定(Binding)的自訂Control，可以繼承自BaseField基底類別，而非 BindableElement。繼承BaseField有以下好處 有實作一個泛型的INotifyValueChanged 預設focusable 提供一個水平佈局(horizontal layout)，左側為label element，右側為input element VisualElement不會綁定到GameObject的生命週期函數，也就是說它不會收到以下callbacks Awake() OnEnable() OnDisable() OnDestroy() 可以在自訂control中的constructor做初始化的動作，但是如果你想要將初始化的動作延遲到這個自訂的control被加到UI之後，可以把初始化的動作加到AttachToPanelEvent callback 使用DetachFromPanelEvent callback可以偵測你自訂的control是否已經從UI上移除 12345678public CustomControl(){ var myCustomElement = rootVisualElement.Q(className: &quot;my-custom-element&quot;); myCustomElement.RegisterCallback&lt;AttachToPanelEvent&gt;(e =&gt; { /* 此處放置當這個elemenet被加入到UI上要做的事 */ }); myCustomElement.RegisterCallback&lt;DetachFromPanelEvent&gt;(e =&gt; { /* 此處放置當這個elemenet從UI上移除後要做的事 */ });} UI Toolkit會分派這兩個事件(AttachToPanelEvent與DetachFromPanelEvent)給所有element 要讓UXML與UI Builder使用你自訂的control，需要定義一個繼承UxmlFactory&lt;T&gt;的factory class將你自訂的control暴露給他們。 綁定資料需要實作INotifyValueChanged並根據需要監聽ChangeEvent。繼承BindableElement或是實作IBindable。 你可以創建USS custom properties以設定自訂控制項的樣式。 Reference: https://docs.unity3d.com/Manual/UIE-create-custom-controls.html","link":"/2024/04/28/%E8%87%AA%E8%A8%82control/"},{"title":"點擊事件(Click events)","text":"當一個Visual Element被滑鼠左鍵(或點擊裝置(pointing device)的第一個按鈕)點擊，將觸發一個Click Event。進行點擊操作的Visual Element會觸發Pointer Down Event與Pointer up Event。此外Click Event也可以檢測到非按鈕Visual Element的點擊，例如Toggle control便是使用了Click Event來處理顯示，隱藏勾號(check mask)並改變control的值。 Event 描述 Trickles down Bubbles up Cancellable ClickEvent 當滑鼠左鍵點擊時，就會觸發一個Click Event ✔ ✔ ✔ 註冊Click Event12345678// 使用RegisterCallback註冊ClickEvent，同時還傳入一個VisualElement參數// 這個asset是當click event被觸發之後，要關閉的elementbtnClose.RegisterCallback&lt;ClickEvent, VisualElement&gt;(Clicked, asset); private void Clicked(ClickEvent evt, VisualElement root){ root.ShowVisualElement(false); } 例子：以下例子示範如何使用Click Event讓一個visual element在被點擊之後將原有顏色，替換為另一個新的顏色。 在Assets &gt; Scripts &gt; Editor 下建立一個 C# Script ClickEventExampleWindow.cs 將以下程式碼複製到剛剛建立的C# Script中123456789101112131415161718192021222324252627282930313233343536373839404142434445using UnityEditor;using UnityEngine;using UnityEngine.UIElements;public class ClickEventExampleWindow : EditorWindow{ // 這個Attributes會在 Windows -&gt; UI Tollkit 下加入一個 ClickEventExample [MenuItem(&quot;Window/UI Toolkit/ClickEventExample&quot;)] public static void ShowExample() { var wnd = GetWindow&lt;ClickEventExampleWindow&gt;(); wnd.titleContent = new GUIContent(&quot;Click Event Example&quot;); } public void CreateGUI() { // 建立四個不同顏色的box for (int i = 0; i &lt; 4; i++) { // 為這些Visual Element設定隨機的background顏色 var newBox = new VisualElement() { style = { flexGrow = 1, backgroundColor = GetRandomColor() } }; rootVisualElement.Add(newBox); // 為這個Element註冊一個ClickEvent callback newBox.RegisterCallback&lt;ClickEvent&gt;(OnBoxClicked); } } // 這個callback會改變target的Background color。 private void OnBoxClicked(ClickEvent evt) { // 只在taget階段執行這個callback if (evt.propagationPhase != PropagationPhase.AtTarget) return; // 設定新的Background color var targetBox = evt.target as VisualElement; targetBox.style.backgroundColor = GetRandomColor(); } private Color GetRandomColor() { return new Color(Random.Range(0, 1f), Random.Range(0, 1f), Random.Range(0, 1f)); }} 在Unity編輯器中找到 Window &gt; UI Toolkit &gt; ClickEventExample 觀看結果 Reference: https://docs.unity3d.com/Manual/UIE-Click-Events.html","link":"/2024/04/22/%E9%BB%9E%E6%93%8A%E4%BA%8B%E4%BB%B6-Click-events/"},{"title":"處理事件(Handle Event)","text":"UI Toolkit Events類似於HTML Events，當事件(Event)發生時，該事件就會發送給target visual element以及在事件傳播路徑(propagation path)上的visual elements。 處理事件的順序如下： 由root element往下直到目標(target)的parent element，都會執行event callback，稱為trickle-down phase 在事件目標執行event callback，稱為target phase 在事件目標上面呼叫ExecuteDefaultActionAtTarget() 由事件目標的parent element往上直到root element都會執行event callbacks，稱為bubble-up phase 在事件目標上面呼叫ExecuteDefaultAction() 註冊Event Callbacks(Register an event callback)可以在class中註冊callback，為個別的instance自訂行為(behavior)，例如滑鼠點擊text label時作出反應。除了目標(target)以外，沿著傳播路徑經過的element都會接收到兩次event 一次是在trickle-down phase 另外一次是bubble-up phase 使用element的RegisterCallback方法來註冊一個event callback element.RegisterCallback&lt;MouseDownEvent&gt;(CallbackMethod); 此例中把CallbackMethod註冊到MouseDownEvent 1myElement.RegisterCallback&lt;MouseDownEvent&gt;(MyCallback); 預設中，註冊的event callback會在target phase與bubble-up phase的時候執行，這樣可以確保父element會在子element之後做出反應。 如果你想要父element在子element之前做出反應可以在註冊event時，將其設定為TrickleDown.TrickleDown 12345678910111213using UnityEngine;using UnityEngine.UIElements;...VisualElement myElement = new VisualElement();// 為這個myElement註冊一個trickle-down phase的callback， // 這會讓dispatcher在target phase與trickle-down phase時執行此MyCallbackmyElement.RegisterCallback&lt;MouseDownEvent&gt;(MyCallback, TrickleDown.TrickleDown);// 定義一個callbackvoid MyCallback(MouseDownEvent evt) { /* ... */ }... 在一個element中，你可以對同一個event註冊多個callback，但是你只能在同一事件和傳播階段註冊一次相同的callback。 有參數的callback12345// 此將會向MyCallbackWithData傳送一個MyType的參數myElement.RegisterCallback&lt;MouseDownEvent, MyType&gt;(MyCallbackWithData, myData);// 定義一個有參數的callbackvoid MyCallbackWithData(MouseDownEvent evt, MyType data) { /* ... */ } 移除註冊的callback使用myElement.UnregisterCallback()移除註冊的callback。 監聽valueUI controls會使用value屬性來存放資料，例如 Toggle會持有一個boolean屬性，當Toggle關閉(off)時設為false，開啟(on)時設為true。 IntegerField會持有一個integer屬性，用來保存該field的值。 int val = myIntegerField.value; 透過RegisterValueChangedCallback你可以註冊一個監聽ChangeEvent事件的callback RegisterValueChangedCallback是RegisterCallback&lt;ChangeEvent&gt;的簡寫，它是透過INotifyValueChange interface來為VisualElement推測正確的Type T 12345// 為myIntegerField註冊一個監聽值改變的OnIntegerFieldChange callbackmyIntegerField.RegisterValueChangedCallback(OnIntegerFieldChange); // 定義一個callbackvoid OnIntegerFieldChange(ChangeEvent&lt;int&gt; evt) { /* ... */ } 更改Value有以下方式 直接更改value屬性，這會觸發一個新的ChangeEvent myControl.value = myNewValue; 使用該element的SetValueWithoutNotify()更改，這不會觸發一個新的ChangeEvent myControl.SetValueWithoutNotify(myNewValue); 獲取Pointer當visual element獲取一個Pointer時，Unity會向這個visual element發送所有與這個Pointer相關的Events，而不管是否這個Pointer懸停(hovers over)在這個visual element上，舉例來說，假設你建立了一個control，他會接收drag events並獲取pointer，不論pointer的位置為何，這個control都會接收drag events Event與自訂Control當自訂Control時，有兩種方式回應UI Toolkit events 註冊一個event callback 實作一個default action callbacks與default action的差異 callback必須要註冊在一個實體物件上；default action則是類似在class上的virtual functions 所有在傳播路徑(propagation path)上的visual element都會執行callback；Default actions只會在event target上執行。 callbacks可能會需要額外檢查是否是需要做出反應的event；default actions可以省略這個步驟 callbacks效能可能較差，default actions會好一些 因為callbacks在propagation phase時需要在註冊表(callback registry)裡面搜尋，而default actions則不需要 實作Default Action若要實作Default Action的話，需要繼承VisualElement，並實作ExecuteDefaultActionAtTarget()或是ExecuteDefaultAction()，或兩個方法都實作。如果實作了Default Action，會應用到該class的所有實體(instances) 如果你想要在parent callback之前執行default action可以把default action放到ExecuteDefaultActionAtTarget() 應該將default actions視為該element type要有的行為(behaviors)，例如：chcekbox觸發click event更新它的狀態時應override default action，而不是為所有checkbox註冊一個callback 123456789101112131415override void ExecuteDefaultActionAtTarget(EventBase evt){ // Call the base function. base.ExecuteDefaultActionAtTarget(evt); if (evt.eventTypeId == MouseDownEvent.TypeId()) { // ... } else if (evt.eventTypeId == MouseUpEvent.TypeId()) { // ... } // More event types} custom controls的最佳實踐 如果是element有的行為(behaviors)，你應該實作在default action 在callback中，你可以使用PreventDefault()來取消該element的 default action。 若一個instance沒有callback，那麼它不會進入propagation process 在事件分派過程(event dispatch process)中，有兩個時段可以執行你的default action 若想在trickle-down與bubble-up之間，在target callbacks之後立刻執行的話，override這個ExecuteDefaultActionsAtTarget()方法 在事件分派過程(event dispatch process)結束時，override這個ExecuteDefaultActions()方法 如果可能的話，盡量將default action寫在ExecuteDefaultActions()，在事件傳播過程(event propagation process)中的trickle-down階段或是bubble-up階段，可以透過PreventDefault()來覆蓋預設的操作。 如果一個事件不應該傳播到parent element的話，你必須要把傳播停下 例如：一個TextField在收到一個KeyDownEvent去修改它的值時，不應該讓這個事件傳播到它的parent visual element 使用ExecuteDefaultActionsAtTarget()實作default action時，可以呼叫StopPropagation()這可以確保event在bubble-up階段時不會處理 Default actions僅針對event target執行，要讓class對target的child element或parent element的事件作出反應，則必須在event的trickle-down或是bubble-up傳播階段之一註冊callback以接收該事件。 為了提高性能，盡量避免在的class中註冊回調函式。 一個parent panel可以在trickle-down階段停止傳播，避免事件傳到它的children 你無法在event class本身中阻止EventBase.PreDispatch()和EventBase.PostDispatch()方法的執行 可以透過以下方法事件傳播(event propagation) StopImmediatePropagation()：立刻停止事件傳播，其他callback不會執行這個event，但是ExecuteDefaultActionAtTarget()與ExecuteDefaultAction() default actions 仍然會執行。 StopPropagation()：在這個element上的最後一個callback執行完之後，停止傳播。這可以確保所有在這個element上的callback都執行完，不會有更多element去對這個事件做出反應。ExecuteDefaultActionAtTarget()與ExecuteDefaultAction() default actions 仍然會執行。 PreventDefault()：在事件傳播過程(event propagation process)時，避免呼叫ExecuteDefaultActionAtTarget()與ExecuteDefaultAction()。 PreventDefault()不會阻止其他callback的執行。 在bubble-up階段時，PreventDefault()不會影響ExecuteDefaultActionAtTarget() action。 Reference：https://docs.unity3d.com/Manual/UIE-Events-Handling.html","link":"/2024/04/17/%E8%99%95%E7%90%86%E4%BA%8B%E4%BB%B6-Handle-Event/"},{"title":"輸入事件(Input events)","text":"當字串透過使用者輸入到Text field時，便會觸發InputEvent，與觸碰螢幕的PointerCaptureOutEvent類似。對於預設的鍵盤輸入，每次按一下鍵(keystroke)都會觸發InputEvent。但是對於間接來源(indirect source)的輸入，將不會觸發InputEvent，例如自動化腳本(automated script)。 專屬於Input Event的屬性 previousData: 存放先前的資料 newData: 存放新的資料 當資料輸入到繼承了TextInputBaseField的control便會發送InputEvent，InputEvent不同於ChangeEvent的地方在於，即使輸入到control的資料沒改變，它也會發送InputEvent。 例子：下面例子為一個TextField註冊一個InputEvent，每當觸發便會印出輸出的的值 在Assets &gt; Scripts &gt; Editor 下建立一個 C# Script InputEventExample.cs 將以下程式碼複製到剛剛建立的C# Script中123456789101112131415161718192021222324252627282930using UnityEditor;using UnityEngine;using UnityEngine.UIElements;public class InputEventExample : EditorWindow{ // 這個Attributes會在 Windows -&gt; UI Tollkit 下加入一個 InputEventExample [MenuItem(&quot;Window/UI Toolkit/InputEventExample&quot;)] public static void ShowExample() { var wnd = GetWindow&lt;InputEventExample&gt;(); wnd.titleContent = new GUIContent(&quot;Input Event Example&quot;); } public void CreateGUI() { // 建立 TextField TextField textField = new TextField(); rootVisualElement.Add(textField); // 註冊InputEvent textField.RegisterCallback&lt;InputEvent&gt;(OnInput); } private void OnInput(InputEvent evt) { // 印出InputEvent中的newData與previousData Debug.Log(&quot;newData=&quot; + evt.newData + &quot; previousData=&quot; + evt.previousData); }} 在Unity編輯器中找到 Window &gt; UI Toolkit &gt; InputEventExample 顯示結果 Reference: https://docs.unity3d.com/Manual/UIE-Input-Events.html","link":"/2024/04/22/%E8%BC%B8%E5%85%A5%E4%BA%8B%E4%BB%B6-Input-events/"},{"title":"使用Action Editor編輯Input","text":"在Project-Wide Actions中可以建立一個整個專案可用的Action Asset，此外你也可以自己再額外建立更多的Action Asset，在編輯器中，選擇Create &gt; Input Actions 便可建立一個Action Asset。 滑鼠左鍵點擊兩次剛剛建立的Action檔案，便可以打開編輯畫面(Actions Editor) Name 描述 Action Maps 顯示目前定義的Action Maps Actions 顯示目前選中的Action Map擁有的Action以及Binding Properties 顯示目前選中Action或是Binding的屬性(properties) 設定Action Maps：在Action Maps旁邊的+可以添加Action Map，對新增的Action Map按下兩次滑鼠左鍵可以對它命名， 注意Action Map的名稱不可以包含 / (slashes)， 設定Action：在Action旁邊的+可以添加Action，對新增的Action按下兩次滑鼠左鍵可以對它命名 Action的屬性 Action Type：可以選擇Button，Value或是PassThrough 若你的Action為鍵盤按鈕，滑鼠點擊或是搖桿按鈕控制的話，選擇Button，如果有多個裝置接上，那麼只會選擇一個最活躍的輸入裝置的輸入(稱為Conflicting inputs) 若是滑鼠移動或是搖桿移動這種屬於連續不斷改變的輸入的話，選擇Value PassThrough和Value相同，差別在於不處理衝突，即會發送所有綁定此Action裝置的輸入。 Control Type：讓你選擇此Action期望的控制類型，這可以限制哪些控制設備可以顯示在UI上，例如選擇了2D axis，那麼在選擇綁定時只有那些支援2D vector的控制設備會顯示在選項上。 Binding：在添加的自訂Action旁邊的+可以為這個Action新增Binding。可以在一個Action上添加多個Binding以支援多個類型的輸入裝置。 Composite Bindings：為多個Binding組成， 例如Up/Down/Left/Right Composite就是在模擬2D搖桿(2D stick input)的輸入 可以透過Duplicate添加不同的 Binding 在Action Editor左上角可以找到Control Schemes，讓你可以根據不同的裝置啟用或是停用Action的Bindings 上一篇：將Action設為整個專案可用(Project-Wide Actions) 下一篇：Actions概念","link":"/2024/04/25/%E8%A8%AD%E5%AE%9AAction/"}],"tags":[{"name":"Joint 2D","slug":"Joint-2D","link":"/tags/Joint-2D/"},{"name":"物理相關","slug":"物理相關","link":"/tags/%E7%89%A9%E7%90%86%E7%9B%B8%E9%97%9C/"},{"name":"Input System","slug":"Input-System","link":"/tags/Input-System/"},{"name":"C#","slug":"C","link":"/tags/C/"},{"name":"SQL語法","slug":"SQL語法","link":"/tags/SQL%E8%AA%9E%E6%B3%95/"},{"name":"UI Toolkit","slug":"UI-Toolkit","link":"/tags/UI-Toolkit/"},{"name":"Eclipse","slug":"Eclipse","link":"/tags/Eclipse/"},{"name":"html","slug":"html","link":"/tags/html/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Google Search Console","slug":"Google-Search-Console","link":"/tags/Google-Search-Console/"},{"name":"sitemap","slug":"sitemap","link":"/tags/sitemap/"},{"name":"Flex","slug":"Flex","link":"/tags/Flex/"},{"name":"JSON Pretty","slug":"JSON-Pretty","link":"/tags/JSON-Pretty/"},{"name":"JSON Formatter","slug":"JSON-Formatter","link":"/tags/JSON-Formatter/"},{"name":"Mac","slug":"Mac","link":"/tags/Mac/"},{"name":"UI Builder","slug":"UI-Builder","link":"/tags/UI-Builder/"},{"name":"Unity package","slug":"Unity-package","link":"/tags/Unity-package/"},{"name":"Unity架構","slug":"Unity架構","link":"/tags/Unity%E6%9E%B6%E6%A7%8B/"},{"name":"Event","slug":"Event","link":"/tags/Event/"},{"name":"DB","slug":"DB","link":"/tags/DB/"},{"name":"Chrome","slug":"Chrome","link":"/tags/Chrome/"},{"name":"delegate","slug":"delegate","link":"/tags/delegate/"},{"name":"taiwan_id","slug":"taiwan-id","link":"/tags/taiwan-id/"}],"categories":[{"name":"Design Pattern","slug":"Design-Pattern","link":"/categories/Design-Pattern/"},{"name":"大綱","slug":"大綱","link":"/categories/%E5%A4%A7%E7%B6%B1/"},{"name":"Unity","slug":"Unity","link":"/categories/Unity/"},{"name":"AWS","slug":"AWS","link":"/categories/AWS/"},{"name":"Chrome","slug":"Chrome","link":"/categories/Chrome/"},{"name":"C# 語言","slug":"C-語言","link":"/categories/C-%E8%AA%9E%E8%A8%80/"},{"name":"SQL","slug":"SQL","link":"/categories/SQL/"},{"name":"IDE操作","slug":"IDE操作","link":"/categories/IDE%E6%93%8D%E4%BD%9C/"},{"name":"Tools","slug":"Tools","link":"/categories/Tools/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Mac","slug":"Mac","link":"/categories/Mac/"},{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"}],"pages":[]}